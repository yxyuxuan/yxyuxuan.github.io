---
title: 对JavaScript理解的困惑点整理
date: 2018-03-25 10:30:40
tags: JavaScript
---



> 难得今天上班不忙！！！重新整理了一下我对JS理解的几个困惑点，之前一直处于模糊的状态，似懂非懂！！！



### 同步和异步

同步： 

```
console.log('我要做第一件事情');
console.log('我要做第二件事情');
```

这段代码的实现就叫做同步,也就是说按照顺序去做,做完第一件事情之后,再去做第二件事情

异步：

```
console.log('我要做第一件事情');
setTimeout(function () {
  console.log('我突然有事,晚点再做第二件事情');
},1000)
console.log('我要做第三件事情');
```

这段代码的实现就叫做异步,也就是说不完全按照顺序去做,
突发情况,第二件事情不能立刻完成,所以等待一段时间再去完成,
优先去做后面的第三件事情,这样就不耽搁时间。



**为什么需要异步呢**?

JavaScript是单线程的,那么单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。
JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。所以这就是异步过程的由来。



**我们经常用到的dom事件也是属于一个异步行为**

例子:

```
var button = document.getElement('#btn');
button.addEventListener('click', function(e) {
    console.log('按钮');
});
```

从事件的角度来看，上述代码表示：在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用。

从异步过程的角度看，addEventListener函数就是异步过程的发起函数，事件监听函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行。



### **回调函数**

回调函数的理解：在JavaScript中function是内置的类对象。它可以存储在变量中，通过参数传递给另一个函数，在函数内部创建，从函数中返回结果值。

回调函数被认为是一种高级函数，一种被作为参数传递给另一个函数(在这称作"otherFunction")的高级函数，回调函数会在otherFunction内被调用(或执行)。回调函数的本质是一种模式(一种解决常见问题的模式)，因此回调函数也被称为回调模式。

##### 回调函数是如何实现的？

我们可以像使用变量一样使用函数，作为另一个函数的参数，在另一个函数中作为返回结果，在另一个函数中调用它。当我们作为参数传递一个回调函数给另一个函数时，我们只传递了这个函数的定义，并没有在参数中执行它。

当包含(调用)函数拥有了在参数中定义的回调函数后，它可以在任何时候调用(也就是回调)它。

这说明回调函数并不是立即执行，而是在包含函数的函数体内指定的位置“回调”它(形如其名)。

```
function f1(callback){
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　callback();
　　　　}, 1000);
　　}

f1(f2); 
```



### promise

字面上理解promise是“承诺”，就是说A调用B，B返回一个承诺给A，然后A就可以在写计划的时候这么写：当B返回结果给我的时候，A执行方案S1，反之若B没有返回给A想要的结果，那么A执行应急方案S2，这样所有的潜在风险都在A的可控范围之内了。

Promise是抽象异步处理对象以及对其进行各种操作的组件。

所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。

有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。



Promise规范如下：

- 一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）

- 一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换

- promise必须实现`then`方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致

- then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。

  ​

promise 的缺点：

- 无法取消 Promise，一旦新建它就会立即执行，无法中途取消。
- 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。



##### 为什么"绝对不能对异步回调函数（即使在数据已经就绪）进行同步调用。"？

如果某函数含有异步过程，那么不要同步调用此异步函数。因为很有可能你调用这个函数的时候，异步过程还没执行。所以一般是在异步的回调中进行之后的过程。



### 进程和线程

JavaScript语言的执行环境是“单线程”。

“进程”， 指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。

”线程“，1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）。线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。

“单线程”，是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，在执行后面一个任务。

“多线程”， 指1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务



### **库** （Library）和**框架**（Framework）的区别:

库是将代码集合成的一个产品，供程序员调用。面向对象的代码组织形式而成的库也叫类库。面向过程的代码组织形式而成的库也叫函数库。在函数库中的可直接使用的函数叫库函数。开发者在使用库的时候，只需要使用库的一部分类或函数，然后继续实现自己的功能。

框架则是为解决一类问题而开发的产品，框架用户一般只需要使用框架提供的类或函数，即可实现全部功能。可以说，框架是库的升级版。开发者在使用框架的时候，必须使用这个框架的全部代码。