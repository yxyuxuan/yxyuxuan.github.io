<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="于禤的博客">
<meta property="og:url" content="https://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="于禤的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="于禤的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/page/3/"/>





  <title>于禤的博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">于禤的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/28/Vue-js中的表单控件绑定/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/28/Vue-js中的表单控件绑定/" itemprop="url">Vue.js中的表单控件绑定</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-28T20:28:57+08:00">
                2016-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>可以用 v-model 指令在表单控件元素上创建双向数据绑定。根据控件类型它自动选取正确的方法更新元素。尽管有点神奇，v-model 不过是语法糖，在用户输入事件中更新数据，以及特别处理一些极端例子。</p>
<p>1.text</p>
<pre><code>&lt;span&gt;Message is: {{ message }}&lt;/span&gt;
&lt;br&gt;
&lt;input type=&quot;text&quot; v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;
</code></pre><p><br><br>result:</p>
<p>Message is:</p>
 <input type="text" v-model="message" placeholder="edit me">

<p>2.multiline text</p>
<pre><code>&lt;span&gt;Multiline message is:&lt;/span&gt;
&lt;p&gt;{{ message }}&lt;/p&gt;
&lt;br&gt;
&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;
</code></pre><p>result:</p>
<p>Message is:</p>
 <textarea v-model="message" placeholder="add multiple lines"></textarea>

<p>3.Checkbox</p>
<p>单个勾选框，逻辑值：</p>
<pre><code>&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
&lt;label for=&quot;checkbox&quot;&gt;{{ checked }}&lt;/label&gt;
</code></pre><p> <input type="checkbox" id="checkbox" v-model="checked">false</p>
<p>4.多个勾选框，绑定到同一个数组：</p>
<pre><code>//.html
&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;
&lt;br&gt;
&lt;span&gt;Checked names: {{ checkedNames | json }}&lt;/span&gt;


//.js
new Vue({
  el: &apos;...&apos;,
  data: {
    checkedNames: []
  }
})
</code></pre><p>5.Radio</p>
<pre><code>&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;
&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;
&lt;br&gt;
&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;
&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;
&lt;br&gt;
&lt;span&gt;Picked: {{ picked }}&lt;/span&gt;
</code></pre><p> <input type="radio" id="one" value="One" v-model="picked"><br>    <label for="one">One</label><br>    <br><br>    <input type="radio" id="two" value="Two" v-model="picked"><br>    <label for="two">Two</label><br>    <br><br>    <span>Picked: </span></p>
<p>6.Select<br>单选：</p>
<pre><code>&lt;select v-model=&quot;selected&quot;&gt;
  &lt;option selected&gt;A&lt;/option&gt;
  &lt;option&gt;B&lt;/option&gt;
  &lt;option&gt;C&lt;/option&gt;
&lt;/select&gt;
&lt;span&gt;Selected: {{ selected }}&lt;/span&gt;
</code></pre><select v-model="selected"><br>  <option selected>A</option><br>  <option>B</option><br>  <option>C</option><br></select><br><br><br><span>Selected:[“A”]</span><br><br>7.绑定 value<br><br>对于单选按钮，勾选框及选择框选项，v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）：<br><br>    <!-- 当选中时，`picked` 为字符串 "a" --><br>    <input type="radio" v-model="picked" value="a"><br><br>    <!-- `toggle` 为 true 或 false --><br>    <input type="checkbox" v-model="toggle"><br><br>    <!-- 当选中时，`selected` 为字符串 "abc" --><br>    <select v-model="selected"><br>      <option value="abc">ABC</option><br>    </select>

<p>但是有时我们想绑定 value 到 Vue 实例的一个动态属性上，这时可以用 v-bind 实现，并且这个属性的值可以不是字符串。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/28/Vue-js中的条件渲染和列表渲染/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/28/Vue-js中的条件渲染和列表渲染/" itemprop="url">Vue.js中的条件渲染和列表渲染</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-28T20:25:41+08:00">
                2016-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-条件渲染"><a href="#一-条件渲染" class="headerlink" title="一.条件渲染"></a>一.条件渲染</h2><h3 id="1-v-if"><a href="#1-v-if" class="headerlink" title="1.v-if"></a>1.v-if</h3><p>例子：</p>
<pre><code>//.html
&lt;div id=&quot;vm&quot;&gt;  
    &lt;h1 v-if=&quot;ok&quot;&gt;ok&lt;/h1&gt;
    &lt;h1 v-else&gt;no&lt;/h1&gt;
&lt;/div&gt;



//.js
window.onload=function(){
  var vm = new Vue({
    el:&apos;#vm&apos;,
    data:{
        ok:true,
        no:false
        }
    });
}
</code></pre><p>result:</p>
<pre><code>ok
</code></pre><h3 id="2-template-v-if"><a href="#2-template-v-if" class="headerlink" title="2.template v-if"></a>2.template v-if</h3><p>因为 v-if 是一个指令，需要将它添加到一个元素上。但是如果我们想切换多个元素呢？此时我们可以把一个 <template> 元素当做包装元素，并在上面使用 v-if，最终的渲染结果不会包含它。</template></p>
<p>例子：</p>
<pre><code>&lt;template v-if=&quot;ok&quot;&gt;
  &lt;h1&gt;Title&lt;/h1&gt;
  &lt;p&gt;Paragraph 1&lt;/p&gt;
  &lt;p&gt;Paragraph 2&lt;/p&gt;
&lt;/template&gt;
</code></pre><h3 id="3-v-show"><a href="#3-v-show" class="headerlink" title="3.v-show"></a>3.v-show</h3><p>v-show指令的用法和v-if用法大体上一样</p>
<p>例子：</p>
<pre><code>&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;
</code></pre><p><strong>注意：</strong> 不同的是有 v-show 的元素会始终渲染并保持在 DOM 中。v-show 是简单的切换元素的 CSS 属性 display。</p>
<p>注意 v-show 不支持 <template> 语法。</template></p>
<h3 id="4-v-else"><a href="#4-v-else" class="headerlink" title="4.v-else"></a>4.v-else</h3><p>可以用 v-else 指令给 v-if 或 v-show 添加一个 “else 块”：</p>
<pre><code>&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;
      Sorry
&lt;/div&gt;
&lt;div v-else&gt;
      Not sorry
&lt;/div&gt;
</code></pre><p><strong>注意：</strong> v-else 元素必须立即跟在 v-if 或 v-show 元素的后面——否则它不能被识别。</p>
<h2 id="二-列表渲染"><a href="#二-列表渲染" class="headerlink" title="二.列表渲染"></a>二.列表渲染</h2><h3 id="1-v-for"><a href="#1-v-for" class="headerlink" title="1.v-for"></a>1.v-for</h3><p>a. 可以使用 v-for 指令基于一个数组渲染一个列表。这个指令使用特殊的语法，形式为 item in items，items 是数据数组，item 是当前数组元素的别名：</p>
<p>例：</p>
<pre><code>//.html
&lt;ul id=&quot;example-1&quot;&gt;
  &lt;li v-for=&quot;item in items&quot;&gt;
    {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;



//.js
var example1 = new Vue({
  el: &apos;#example-1&apos;,
  data: {
    items: [
      { message: &apos;Foo&apos; },
      { message: &apos;Bar&apos; }
    ]
  }
})
</code></pre><p>result:</p>
<ul>
<li>Foo</li>
<li>Bar</li>
</ul>
<p>b. 也可以使用 v-for 遍历对象。除了 $index 之外，作用域内还可以访问另外一个特殊变量 $key。</p>
<p>例子：</p>
<pre><code>//.html
&lt;ul id=&quot;repeat-object&quot; class=&quot;demo&quot;&gt;
  &lt;li v-for=&quot;value in object&quot;&gt;
    {{ $key }} : {{ value }}
  &lt;/li&gt;
&lt;/ul&gt;



//.js
new Vue({
  el: &apos;#repeat-object&apos;,
  data: {
    object: {
      FirstName: &apos;John&apos;,
      LastName: &apos;Doe&apos;,
      Age: 30
    }
  }    
})
</code></pre><p>result:</p>
<ul>
<li>FirstName:John</li>
<li>lastname:Doe</li>
<li>Age:30</li>
</ul>
<p><strong>注意：</strong> 在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。</p>
<p>c. v-for也可以接收一个整数，此时它将重复模板数次。</p>
<pre><code>&lt;div&gt;
    &lt;span v-for=&quot;n in 10&quot;&gt;{{n}}&lt;/span&gt;
&lt;/div&gt;
</code></pre><p>result:</p>
<pre><code>0123456789
</code></pre><h3 id="2-template-v-for"><a href="#2-template-v-for" class="headerlink" title="2.template v-for"></a>2.template v-for</h3><p>类似于 template v-if，也可以将 v-for 用在 <template> 标签上，以渲染一个包含多个元素的块。例如：</template></p>
<pre><code>&lt;ul&gt;
  &lt;template v-for=&quot;item in items&quot;&gt;
    &lt;li&gt;{{ item.msg }}&lt;/li&gt;
    &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt;
  &lt;/template&gt;
&lt;/ul&gt;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/24/Node-js中的GET-POST请求/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/24/Node-js中的GET-POST请求/" itemprop="url">Node.js中的GET/POST请求</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-24T18:56:47+08:00">
                2016-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在很多场景中，我们的服务器都需要跟用户的浏览器打交道，如表单提交。<br>表单提交到服务器一般都使用GET/POST请求。</p>
</blockquote>
<h3 id="一-获取GET请求内容"><a href="#一-获取GET请求内容" class="headerlink" title="一.获取GET请求内容"></a>一.获取GET请求内容</h3><p>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。<br>node.js中url模块中的parse函数提供了这个功能。</p>
<pre><code>var http = require(&apos;http&apos;);
var url = require(&apos;url&apos;);
var util = require(&apos;util&apos;);

http.createServer(function(req, res){
    res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});
    res.end(util.inspect(url.parse(req.url, true)));
}).listen(3000);
</code></pre><p>在浏览器中访问<br><a href="http://localhost:3000/user?name=w3c&amp;email=w3c@w3cschool.cc" target="_blank" rel="external">http://localhost:3000/user?name=w3c&amp;email=w3c@w3cschool.cc</a> 然后查看返回结果为:</p>
<pre><code>Url {
  protocol: null,
  slashes: null,
  auth: null,
  host: null,
  port: null,
  hostname: null,
  hash: null,
  search: &apos;?name=w3c&amp;email=w3c@w3cschool.cc&apos;,
  query: { name: &apos;w3c&apos;, email: &apos;w3c@w3cschool.cc&apos; },
  pathname: &apos;/user&apos;,
  path: &apos;/user?name=w3c&amp;email=w3c@w3cschool.cc&apos;,
  href: &apos;/user?name=w3c&amp;email=w3c@w3cschool.cc&apos; }
</code></pre><h3 id="二-获取POST请求内容"><a href="#二-获取POST请求内容" class="headerlink" title="二.获取POST请求内容"></a>二.获取POST请求内容</h3><p>POST请求的内容全部的都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所有node.js默认是不会解析请求体的，当你需要的时候，需要手动来做。</p>
<pre><code>var http = require(&apos;http&apos;);
var querystring = require(&apos;querystring&apos;);
var util = require(&apos;util&apos;);

http.createServer(function(req, res){
    var post = &apos;&apos;;     //定义了一个post变量，用于暂存请求体的信息

    req.on(&apos;data&apos;, function(chunk){  

    //通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
    post += chunk;
    });

    req.on(&apos;end&apos;, function(){    
    //在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
    post = querystring.parse(post);
    res.end(util.inspect(post));
    });
}).listen(3000);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/24/Node-js中的RESTful/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/24/Node-js中的RESTful/" itemprop="url">Node.js中的RESTful</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-24T18:54:13+08:00">
                2016-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一-什么是-REST？"><a href="#一-什么是-REST？" class="headerlink" title="一.什么是 REST？"></a>一.什么是 REST？</h3><p>REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。</p>
<p>表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。</p>
<h3 id="二-HTTP-方法"><a href="#二-HTTP-方法" class="headerlink" title="二.HTTP 方法"></a>二.HTTP 方法</h3><p>以下为 REST 基本架构的四个方法：</p>
<ol>
<li>GET - 用于获取数据。</li>
<li>PUT - 用于添加数据。</li>
<li>DELETE - 用于删除数据。</li>
<li>POST - 用于更新或添加数据。</li>
</ol>
<h3 id="三-RESTful-Web-Services"><a href="#三-RESTful-Web-Services" class="headerlink" title="三.RESTful Web Services"></a>三.RESTful Web Services</h3><p>Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。</p>
<p>基于 REST 架构的 Web Services 即是 RESTful。</p>
<p>由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法。可以使用各种语言（比如 Java 程序、Perl、Ruby、Python、PHP 和 Javascript[包括 Ajax]）实现客户端。</p>
<p>RESTful Web 服务通常可以通过自动客户端或代表用户的应用程序访问。但是，这种服务的简便性让用户能够与之直接交互，使用它们的 Web 浏览器构建一个 GET URL 并读取返回的内容。</p>
<p>首先，创建一个 json 数据资源文件 users.json，内容如下：</p>
<pre><code>{
   &quot;user1&quot; : {
   &quot;name&quot; : &quot;mahesh&quot;,
   &quot;password&quot; : &quot;password1&quot;,
   &quot;profession&quot; : &quot;teacher&quot;,
   &quot;id&quot;: 1
},
&quot;user2&quot; : {
   &quot;name&quot; : &quot;suresh&quot;,
   &quot;password&quot; : &quot;password2&quot;,
   &quot;profession&quot; : &quot;librarian&quot;,
   &quot;id&quot;: 2
},
&quot;user3&quot; : {
   &quot;name&quot; : &quot;ramesh&quot;,
   &quot;password&quot; : &quot;password3&quot;,
   &quot;profession&quot; : &quot;clerk&quot;,
   &quot;id&quot;: 3
   }
}
</code></pre><p><strong>获取用户列表：</strong></p>
<p>以下代码，我们创建了 RESTful API listUsers，用于读取用户的信息列表， server.js 文件代码如下所示：</p>
<pre><code>var express = require(&apos;express&apos;);
var app = express();
var fs = require(&quot;fs&quot;);

app.get(&apos;/listUsers&apos;, function (req, res) {
    fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &apos;utf8&apos;, function (err, data) {
       console.log( data );
       res.end( data );
   });
})

var server = app.listen(8081, function () {

  var host = server.address().address
  var port = server.address().port

  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)

})
</code></pre><p>接下来执行以下命令：</p>
<pre><code>$ node server.js 
应用实例，访问地址为 http://0.0.0.0:8081
</code></pre><p>在浏览器中访问 <a href="http://127.0.0.1:8081/listUsers，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081/listUsers，结果如下所示：</a></p>
<pre><code>{
   &quot;user1&quot; : {
   &quot;name&quot; : &quot;mahesh&quot;,
   &quot;password&quot; : &quot;password1&quot;,
   &quot;profession&quot; : &quot;teacher&quot;,
   &quot;id&quot;: 1
},
&quot;user2&quot; : {
   &quot;name&quot; : &quot;suresh&quot;,
   &quot;password&quot; : &quot;password2&quot;,
   &quot;profession&quot; : &quot;librarian&quot;,
   &quot;id&quot;: 2
},
&quot;user3&quot; : {
   &quot;name&quot; : &quot;ramesh&quot;,
   &quot;password&quot; : &quot;password3&quot;,
   &quot;profession&quot; : &quot;clerk&quot;,
   &quot;id&quot;: 3
}
}
</code></pre><p><strong>添加用户</strong></p>
<p>以下代码，我们创建了 RESTful API addUser， 用于添加新的用户数据，server.js 文件代码如下所示：</p>
<pre><code>var express = require(&apos;express&apos;);
var app = express();
var fs = require(&quot;fs&quot;);

//添加的新用户数据
var user = {
  &quot;user4&quot; : {
  &quot;name&quot; : &quot;mohit&quot;,
  &quot;password&quot; : &quot;password4&quot;,
  &quot;profession&quot; : &quot;teacher&quot;,
  &quot;id&quot;: 4
 }
}

app.get(&apos;/addUser&apos;, function (req, res) {
// 读取已存在的数据
fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &apos;utf8&apos;, function (err, data) {
   data = JSON.parse( data );
   data[&quot;user4&quot;] = user[&quot;user4&quot;];
   console.log( data );
   res.end( JSON.stringify(data));
});
})

var server = app.listen(8081, function () {

  var host = server.address().address
  var port = server.address().port
  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)

})
</code></pre><p>接下来执行以下命令：</p>
<pre><code>$ node server.js 
 应用实例，访问地址为 http://0.0.0.0:8081
</code></pre><p>在浏览器中访问 <a href="http://127.0.0.1:8081/addUser，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081/addUser，结果如下所示：</a></p>
<pre><code>{ user1:
   { name: &apos;mahesh&apos;,
     password: &apos;password1&apos;,
     profession: &apos;teacher&apos;,
     id: 1 },
  user2:
   { name: &apos;suresh&apos;,
     password: &apos;password2&apos;,
     profession: &apos;librarian&apos;,
     id: 2 },
  user3:
   { name: &apos;ramesh&apos;,
     password: &apos;password3&apos;,
     profession: &apos;clerk&apos;,
     id: 3 },
  user4:
       { name: &apos;mohit&apos;,
     password: &apos;password4&apos;,
     profession: &apos;teacher&apos;,
     id: 4 } 
}
</code></pre><p><strong>显示用户详情</strong></p>
<p>以下代码，我们创建了 RESTful API :id（用户id）， 用于读取指定用户的详细信息，server.js 文件代码如下所示：</p>
<pre><code>var express = require(&apos;express&apos;);
var app = express();
var fs = require(&quot;fs&quot;);

app.get(&apos;/:id&apos;, function (req, res) {
// 首先我们读取已存在的用户
fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &apos;utf8&apos;, function (err, data) {
   data = JSON.parse( data );
   var user = data[&quot;user&quot; + req.params.id] 
   console.log( user );
   res.end( JSON.stringify(user));
 });
})

var server = app.listen(8081, function () {

   var host = server.address().address
   var port = server.address().port
   console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)

})
</code></pre><p>接下来执行以下命令：</p>
<pre><code>$ node server.js 
应用实例，访问地址为 http://0.0.0.0:8081
</code></pre><p>在浏览器中访问 <a href="http://127.0.0.1:8081/2，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081/2，结果如下所示：</a></p>
<pre><code>{
   &quot;name&quot;:&quot;suresh&quot;,
   &quot;password&quot;:&quot;password2&quot;,
   &quot;profession&quot;:&quot;librarian&quot;,
   &quot;id&quot;:2
}
</code></pre><p><strong>删除用户</strong></p>
<p>以下代码，我们创建了 RESTful API deleteUser， 用于删除指定用户的详细信息，以下实例中，用户 id 为 2，server.js 文件代码如下所示：</p>
<pre><code>var express = require(&apos;express&apos;);
var app = express();
var fs = require(&quot;fs&quot;);

var id = 2;

app.get(&apos;/deleteUser&apos;, function (req, res) {

   // First read existing users.
   fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &apos;utf8&apos;, function (err, data) {
       data = JSON.parse( data );
       delete data[&quot;user&quot; + 2];

       console.log( data );
       res.end( JSON.stringify(data));
   });
})

var server = app.listen(8081, function () {

  var host = server.address().address
  var port = server.address().port
  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)

})
</code></pre><p>接下来执行以下命令：</p>
<pre><code>$ node server.js 
应用实例，访问地址为 http://0.0.0.0:8081
</code></pre><p>在浏览器中访问 <a href="http://127.0.0.1:8081/deleteUser，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081/deleteUser，结果如下所示：</a></p>
<pre><code>{ user1:
   { name: &apos;mahesh&apos;,
     password: &apos;password1&apos;,
     profession: &apos;teacher&apos;,
     id: 1 },
  user3:
   { name: &apos;ramesh&apos;,
     password: &apos;password3&apos;,
     profession: &apos;clerk&apos;,
     id: 3 } 
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/23/Node-js中的events模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/23/Node-js中的events模块/" itemprop="url">Node.js中的events模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-23T21:16:55+08:00">
                2016-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> <strong>注意：</strong></p>
<ol>
<li><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p>
</li>
<li><p>Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p>
</li>
</ol>
<hr>
<h3 id="一-EventEmitter类"><a href="#一-EventEmitter类" class="headerlink" title="一.EventEmitter类"></a>一.EventEmitter类</h3><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。可以通过require(“events”);来访问该模块。</p>
<pre><code>// 引入 events 模块
var events = require(&apos;events&apos;);
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
</code></pre><p>EventEmitter 对象如果在实例化时发生错误，会触发 ‘error’ 事件。当添加新的监听器时，’newListener’ 事件会触发，当监听器被移除时，’removeListener’ 事件被触发。</p>
<h3 id="二-EventEmitter-的用法："><a href="#二-EventEmitter-的用法：" class="headerlink" title="二.EventEmitter 的用法："></a>二.EventEmitter 的用法：</h3><pre><code>//event.js 文件
var EventEmitter = require(&apos;events&apos;).EventEmitter; 
var event = new EventEmitter(); 
event.on(&apos;some_event&apos;, function() { 
    console.log(&apos;some_event 事件触发&apos;); 
}); 
setTimeout(function() { 
    event.emit(&apos;some_event&apos;); 
}, 1000); 
</code></pre><p>执行结果如下：<br>运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p>
<pre><code>$ node event.js 
some_event 事件触发
</code></pre><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p>
<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。<br>让我们以下面的例子解释这个过程：</p>
<pre><code>//event.js 文件
var events = require(&apos;events&apos;); 
var emitter = new events.EventEmitter(); 
emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { 
    console.log(&apos;listener1&apos;, arg1, arg2); 
}); 
emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { 
    console.log(&apos;listener2&apos;, arg1, arg2); 
}); 
emitter.emit(&apos;someEvent&apos;, &apos;arg1 参数&apos;, &apos;arg2 参数&apos;); 
</code></pre><p>执行以上代码，运行的结果如下：</p>
<pre><code>$ node event.js 
listener1 arg1 参数 arg2 参数
listener2 arg1 参数 arg2 参数
</code></pre><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。<br>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p>
<h3 id="三-EventEmitter-的属性"><a href="#三-EventEmitter-的属性" class="headerlink" title="三.EventEmitter 的属性"></a>三.EventEmitter 的属性</h3><p> EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p>
<ol>
<li><p>addListener(event, listener)<br>为指定事件添加一个监听器到监听器数组的尾部。</p>
</li>
<li><p>on(event, listener)<br>为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</p>
<pre><code>erver.on(&apos;connection&apos;, function (stream) {
    console.(&apos;someone connected!&apos;);
});
</code></pre></li>
<li><p>once(event, listener)<br>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</p>
<pre><code>server.once(&apos;connection&apos;, function (stream){
    console.log(&apos;Ah, we have our first user!&apos;);
});
</code></pre></li>
<li><p>removeListener(event, listener)<br>移除指定事件的某个监听器，监听器 必须是该事件已经注册过的监听器。</p>
<pre><code>var callback = function(stream) {
       console.log(&apos;someone connected!&apos;);
};
server.on(&apos;connection&apos;, callback);
// ...
server.removeListener(&apos;connection&apos;, callback);
</code></pre></li>
<li><p>removeAllListeners([event])<br>移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</p>
</li>
<li><p>setMaxListeners(n)<br>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</p>
</li>
<li><p>listeners(event)<br>返回指定事件的监听器数组。</p>
</li>
<li><p>emit(event, [arg1], [arg2], […])<br>按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</p>
</li>
</ol>
<h3 id="四-继承-EventEmitter"><a href="#四-继承-EventEmitter" class="headerlink" title="四.继承 EventEmitter"></a>四.继承 EventEmitter</h3><ul>
<li>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</li>
</ul>
<ul>
<li>为什么要这样做呢？原因有两点：<br>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。<br>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/21/Node-js中的fs模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/21/Node-js中的fs模块/" itemprop="url">Node.js中的fs模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-21T22:14:51+08:00">
                2016-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Node.js内置的fs模块就是文件系统模块，负责读写文件。和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。</p>
</blockquote>
<h3 id="一-同步读文件"><a href="#一-同步读文件" class="headerlink" title="一.同步读文件"></a>一.同步读文件</h3><ol>
<li><p>创建一个文件 input.txt ，内容如下：</p>
<pre><code>你好，我是于禤。
Hello!my name is yuxuan.
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);

var data = fs.readFileSync(&apos;input.txt&apos;);

console.log(data.toString());
console.log(&quot;程序执行结束!&quot;);
</code></pre></li>
<li><p>以上代码执行结果如下：</p>
<pre><code>$ node main.js

 你好，我是于禤。
Hello!my name is yuxuan.
程序执行结束!
</code></pre></li>
</ol>
<h3 id="二-异步读文件"><a href="#二-异步读文件" class="headerlink" title="二.异步读文件"></a>二.异步读文件</h3><ol>
<li><p>创建一个文件 input.txt ，内容如下：</p>
<pre><code>你好，我是于禤。
    Hello!my name is yuxuan.
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);

fs.readFile(&apos;input.txt&apos;, function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});

console.log(&quot;程序执行结束!&quot;);
</code></pre></li>
<li><p>以上代码执行结果如下：</p>
<pre><code> 程序执行结束!
 你好，我是于禤。
Hello!my name is yuxuan.
</code></pre></li>
</ol>
<h3 id="三-写文件（fs-writeFile-）"><a href="#三-写文件（fs-writeFile-）" class="headerlink" title="三.写文件（fs.writeFile()）"></a>三.写文件（fs.writeFile()）</h3><ol>
<li><p>创建一个空文件 output.txt</p>
</li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&apos;fs&apos;);

var data = &apos;Hello, Node.js&apos;;
fs.writeFile(&apos;output.txt&apos;, data, function (err) {
    if (err) {
        console.log(err);
    } else {
        console.log(&apos;ok.&apos;);
    }
});
</code></pre></li>
<li><p>执行结果：空文件 output.txt里的内容变为Hello, Node.js。<br>writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。</p>
</li>
<li><p>和readFile()类似，writeFile()也有一个同步方法，叫writeFileSync()：</p>
<pre><code>var fs = require(&apos;fs&apos;);
var data = &apos;Hello, Node.js&apos;;
fs.writeFileSync(&apos;output.txt&apos;, data);
</code></pre></li>
</ol>
<h3 id="四-获取文件的详细信息（fs-stat-）"><a href="#四-获取文件的详细信息（fs-stat-）" class="headerlink" title="四.获取文件的详细信息（fs.stat()）"></a>四.获取文件的详细信息（fs.stat()）</h3><ol>
<li><p>创建一个文件 input.txt ，内容如下：</p>
<pre><code>你好，我是于禤。
Hello!my name is yuxuan.
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&apos;fs&apos;);

fs.stat(&apos;input.txt&apos;, function (err, stat) {
if (err) {
    console.log(err);
} else {
    // 是否是文件:
    console.log(&apos;isFile: &apos; + stat.isFile());
    // 是否是目录:
    console.log(&apos;isDirectory: &apos; + stat.isDirectory());
    if (stat.isFile()) {
        // 文件大小:
        console.log(&apos;size: &apos; + stat.size);
        // 创建时间, Date对象:
        console.log(&apos;birth time: &apos; + stat.birthtime);
        // 修改时间, Date对象:
        console.log(&apos;modified time: &apos; + stat.mtime);
        }
 }
});
</code></pre></li>
<li><p>运行结果如下：</p>
<pre><code>isFile: true
isDirectory: false
size: 51
birth time: Thu Oct 20 2016 13:40:21 GMT+0800 (中国标准时间)
modified time: Thu Oct 20 2016 14:04:41 GMT+0800 (中国标准时间)
</code></pre></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/21/用Node-js实现HTTP服务器程序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/21/用Node-js实现HTTP服务器程序/" itemprop="url">用Node.js实现HTTP服务器程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-21T20:57:26+08:00">
                2016-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近在学习Node.js的基本模块,现用Node.js实现一个HTTP服务器程序</p>
</blockquote>
<p><strong>注意：</strong></p>
<ol>
<li><p>要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。</p>
</li>
<li><p>request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息；</p>
</li>
<li><p>response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。</p>
</li>
</ol>
<hr>
<h3 id="一-让我们先了解下-Node-js-应用是由哪几部分组成的："><a href="#一-让我们先了解下-Node-js-应用是由哪几部分组成的：" class="headerlink" title="一.让我们先了解下 Node.js 应用是由哪几部分组成的："></a>一.让我们先了解下 Node.js 应用是由哪几部分组成的：</h3><ol>
<li><p><strong>引入 required 模块：</strong>我们可以使用 require 指令来载入 Node.js 模块。</p>
</li>
<li><p><strong>创建服务器</strong>：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</p>
</li>
<li><p><strong>接收请求与响应请求:</strong>服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。</p>
</li>
</ol>
<h3 id="二-Node-js实现一个HTTP服务器程序的步骤："><a href="#二-Node-js实现一个HTTP服务器程序的步骤：" class="headerlink" title="二.Node.js实现一个HTTP服务器程序的步骤："></a>二.Node.js实现一个HTTP服务器程序的步骤：</h3><h4 id="1-引入requried模块："><a href="#1-引入requried模块：" class="headerlink" title="1. 引入requried模块："></a>1. 引入requried模块：</h4><p>我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p>
<pre><code>var http = require(&quot;http&quot;);
</code></pre><h3 id="2-创建服务器，接收请求与响应请求："><a href="#2-创建服务器，接收请求与响应请求：" class="headerlink" title="2. 创建服务器，接收请求与响应请求："></a>2. 创建服务器，接收请求与响应请求：</h3><p>接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8080 端口。 函数通过 request, response 参数来接收和响应数据。实例如下：</p>
<pre><code>// 创建http server，并传入回调函数:
var server = http.createServer(function (request, response) {

      // 将HTTP响应200写入response, 同时设置Content-Type: text/html:
      response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/html&apos;});

      // 将HTTP响应的HTML内容写入response:
      response.end(&apos;&lt;h1&gt;Hello world!&lt;/h1&gt;&apos;);
});

// 让服务器监听8080端口:
server.listen(8080,&apos;127.0.0.1&apos;);

//// 终端打印如下信息
console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;);
</code></pre><h3 id="3-在命令提示符下运行该程序，可以看到以下输出："><a href="#3-在命令提示符下运行该程序，可以看到以下输出：" class="headerlink" title="3. 在命令提示符下运行该程序，可以看到以下输出："></a>3. 在命令提示符下运行该程序，可以看到以下输出：</h3><pre><code>$ node hello.js 
Server is running at http://127.0.0.1:8080/
</code></pre><h3 id="4-不要关闭命令提示符，直接打开浏览器输入http-127-0-0-1-8080，即可看到服务器响应的内容："><a href="#4-不要关闭命令提示符，直接打开浏览器输入http-127-0-0-1-8080，即可看到服务器响应的内容：" class="headerlink" title="4. 不要关闭命令提示符，直接打开浏览器输入http://127.0.0.1:8080，即可看到服务器响应的内容："></a>4. 不要关闭命令提示符，直接打开浏览器输入<a href="http://127.0.0.1:8080，即可看到服务器响应的内容：" target="_blank" rel="external">http://127.0.0.1:8080，即可看到服务器响应的内容：</a></h3><pre><code>Hello world!
</code></pre><h2 id="三-分析Node-js-的-HTTP-服务器"><a href="#三-分析Node-js-的-HTTP-服务器" class="headerlink" title="三.分析Node.js 的 HTTP 服务器"></a>三.分析Node.js 的 HTTP 服务器</h2><ul>
<li>第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。</li>
</ul>
<ul>
<li>接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/20/Node-js中的Stream模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/20/Node-js中的Stream模块/" itemprop="url">Node.js中的Stream模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-20T21:12:32+08:00">
                2016-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注意：</strong></p>
<ol>
<li><p>stream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。</p>
</li>
<li><p>什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。</p>
</li>
<li><p>Node.js，Stream 有四种流类型：</p>
<ul>
<li>Readable - 可读操作。</li>
<li>Writable - 可写操作。</li>
<li>Duplex - 可读可写操作.</li>
<li>Transform - 操作被写入数据，然后读出结果。</li>
</ul>
</li>
<li><p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>
<ul>
<li>data - 当有数据可读时触发。</li>
<li>end - 没有更多的数据可读时触发。</li>
<li>error - 在接收和写入过程中发生错误时触发。</li>
<li>finish - 所有数据已被写入到底层系统时触发。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="一-从流中读取数据"><a href="#一-从流中读取数据" class="headerlink" title="一.从流中读取数据"></a>一.从流中读取数据</h3><ol>
<li><p>创建 input.txt 文件，内容如下：</p>
<pre><code>hello world !
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);
var data = &apos;&apos;;

// 创建可读流
var readerStream = fs.createReadStream(&apos;input.txt&apos;);

// 设置编码为 utf8。
readerStream.setEncoding(&apos;UTF8&apos;);

// 处理流事件 --&gt; data, end, and error
readerStream.on(&apos;data&apos;, function(chunk) {
       data += chunk;
   });

readerStream.on(&apos;end&apos;,function(){
       console.log(data);
});

readerStream.on(&apos;error&apos;, function(err){
       console.log(err.stack);
});

    console.log(&quot;程序执行完毕&quot;);
</code></pre></li>
</ol>
<ol>
<li><p>以上代码执行结果如下：</p>
<pre><code>程序执行完毕
hello world !
</code></pre></li>
</ol>
<h3 id="二-写入流"><a href="#二-写入流" class="headerlink" title="二.写入流"></a>二.写入流</h3><ol>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);
var data = &apos;hello world !&apos;;

// 创建一个可以写入的流，写入到文件 output.txt 中
var writerStream = fs.createWriteStream(&apos;output.txt&apos;);

// 使用 utf8 编码写入数据
writerStream.write(data,&apos;UTF8&apos;);

// 标记文件末尾
writerStream.end();

// 处理流事件 --&gt; data, end, and error
writerStream.on(&apos;finish&apos;, function() {
    console.log(&quot;写入完成。&quot;);
});

writerStream.on(&apos;error&apos;, function(err){
       console.log(err.stack);
});

    console.log(&quot;程序执行完毕&quot;);
</code></pre></li>
<li><p>以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：</p>
<pre><code>   $ node main.js 
程序执行完毕
写入完成。
</code></pre></li>
<li><p>查看 output.txt 文件的内容：</p>
<pre><code>$ cat output.txt 
hello world !
</code></pre></li>
</ol>
<h3 id="三-管道流"><a href="#三-管道流" class="headerlink" title="三.管道流"></a>三.管道流</h3><p> 管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。</p>
<p> 以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。</p>
<ol>
<li><p>设置 input.txt 文件内容如下：</p>
<pre><code>Hello! my name is yuxuan.
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);

// 创建一个可读流
var readerStream = fs.createReadStream(&apos;input.txt&apos;);

// 创建一个可写流
var writerStream = fs.createWriteStream(&apos;output.txt&apos;);

// 管道读写操作
// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中
readerStream.pipe(writerStream);

console.log(&quot;程序执行完毕&quot;);
</code></pre></li>
<li><p>代码执行结果如下：</p>
<pre><code>$ node main.js 
程序执行完毕
</code></pre></li>
<li><p>查看 output.txt 文件的内容：</p>
<pre><code>$ cat output.txt 
Hello! my name is yuxuan.
</code></pre></li>
</ol>
<h3 id="四-链式流"><a href="#四-链式流" class="headerlink" title="四.链式流"></a>四.链式流</h3><ul>
<li>链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。<br>接下来我们就是用管道和链式来压缩和解压文件。</li>
</ul>
<p><strong>a. 压缩文件</strong></p>
<ol>
<li><p>创建 compress.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);
var zlib = require(&apos;zlib&apos;);

// 压缩 input.txt 文件为 input.txt.gz
fs.createReadStream(&apos;input.txt&apos;)
.pipe(zlib.createGzip())
.pipe(fs.createWriteStream(&apos;input.txt.gz&apos;));

console.log(&quot;文件压缩完成。&quot;);
</code></pre></li>
<li><p>代码执行结果如下：</p>
<pre><code>$ node compress.js 
文件压缩完成。
</code></pre></li>
<li><p>执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。</p>
</li>
</ol>
<p><strong>b. 解压该文件</strong></p>
<ol>
<li><p>创建 decompress.js 文件，代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);
var zlib = require(&apos;zlib&apos;);

    // 解压 input.txt.gz 文件为 input.txt
fs.createReadStream(&apos;input.txt.gz&apos;)
  .pipe(zlib.createGunzip())
  .pipe(fs.createWriteStream(&apos;input.txt&apos;));

console.log(&quot;文件解压完成。&quot;);
</code></pre></li>
<li><p>代码执行结果如下：</p>
<pre><code>$ node decompress.js 
 文件解压完成。
</code></pre></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="yuxuan" />
          <p class="site-author-name" itemprop="name">yuxuan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuxuan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">本站访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">本站浏览量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
