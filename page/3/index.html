<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="于禤的博客">
<meta property="og:url" content="https://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="于禤的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="于禤的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/page/3/"/>





  <title>于禤的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?78dbf36cfbcb91ad1176516d9f41a290";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">于禤的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/31/Node-js中的module-exports与exports的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/31/Node-js中的module-exports与exports的区别/" itemprop="url">Node.js中的module.exports与exports的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-31T20:34:52+08:00">
                2016-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>每一个node.js执行文件，都自动创建一个module对象，同时，module对象会创建一个叫exports的属性，初始化的值是 {}</p>
</blockquote>
<pre><code>module.exports = {};
</code></pre><p>Node.js为了方便地导出功能函数，node.js会自动地实现以下这个语句</p>
<pre><code>//foo.js

     exports.a = function(){
         console.log(&apos;a&apos;)
     }
     exports.a = 1 


//test.js

     var x = require(&apos;./foo&apos;);
     console.log(x.a)
</code></pre><p>   result:</p>
<pre><code>1    
</code></pre><p>这里，exports是引用 module.exports的值。</p>
<blockquote>
<p>module.exports 被改变的时候，exports不会被改变，而模块导出的时候，真正导出的执行是module.exports，而不是exports<br>再看看下面例子</p>
</blockquote>
<pre><code>//foo.js

     exports.a = function(){
        console.log(&apos;a&apos;)
     }
 module.exports = {a: 2}
 exports.a = 1 


//test.js

 var x = require(&apos;./foo&apos;);
 console.log(x.a)
</code></pre><p>result:2</p>
<p>exports在module.exports 被改变后，失效。</p>
<blockquote>
<p>是不是开始有点廓然开朗，下面将会列出开源模块中，经常看到的几个使用方式。</p>
</blockquote>
<h3 id="1-module-exports-View"><a href="#1-module-exports-View" class="headerlink" title="1. module.exports = View"></a>1. module.exports = View</h3><pre><code>function View(name, options) { 
   options = options || {};
   this.name = name;
   this.root = options.root;
   var engines = options.engines;
   this.defaultEngine = options.defaultEngine;
   var ext = this.ext = extname(name);
   if (!ext &amp;&amp; !this.defaultEngine) throw new Error(&apos;No default engine was specified and no         extension was provided.&apos;);
   if (!ext) name += (ext = this.ext = (&apos;.&apos; != this.defaultEngine[0] ? &apos;.&apos; : &apos;&apos;) +     this.defaultEngine);
   this.engine = engines[ext] || (engines[ext] = require(ext.slice(1)).__express);
   this.path = this.lookup(name);
 }

 module.exports = View;
</code></pre><p>javascript里面有一句话，函数即对象，View 是对象，module.export =View, 即相当于导出整个view对象。外面模块调用它的时候，能够调用View的所有方法。不过需要注意，只有是View的静态方法的时候，才能够被调用，prototype创建的方法，则属于View的私有方法。</p>
<pre><code>//foo.js

     function View(){

     }

     View.prototype.test = function(){
      console.log(&apos;test&apos;)
     }

     View.test1 = function(){
          console.log(&apos;test1&apos;)
     }
     module.exports = View


//test.js

     var x = require(&apos;./foo&apos;);

     console.log(x) //{ [Function: View] test1: [Function] }
     console.log(x.test) //undefined
     console.log(x.test1) //[Function]
     x.test1() //test1
</code></pre><h3 id="2-var-app-exports-module-exports"><a href="#2-var-app-exports-module-exports" class="headerlink" title="2. var app = exports = module.exports = {};"></a>2. var app = exports = module.exports = {};</h3><p>其实，当我们了解到原理后，不难明白这样的写法有点冗余，其实是为了保证，模块的初始化环境是干净的。同时也方便我们，即使改变了 module.exports 指向的对象后，依然能沿用 exports的特性</p>
<pre><code>exports = module.exports = createApplication;

/**
 * Expose mime.
 */

exports.mime = connect.mime;
</code></pre><p>例子当中module.exports = createApplication改变了module.exports了，让exports失效，通过exports = module.exports的方法，让其恢复原来的特点。</p>
<h3 id="3-exports-init-function"><a href="#3-exports-init-function" class="headerlink" title="3. exports.init= function(){}"></a>3. exports.init= function(){}</h3><p>这种最简单，直接就是导出模块 init的方法。</p>
<h3 id="4-var-mongoose-module-exports-exports-new-Mongoose"><a href="#4-var-mongoose-module-exports-exports-new-Mongoose" class="headerlink" title="4.  var mongoose = module.exports = exports = new Mongoose;"></a>4.  var mongoose = module.exports = exports = new Mongoose;</h3><p>集多功能一身。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/30/Vue-js中方法与事件处理器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/30/Vue-js中方法与事件处理器/" itemprop="url">Vue.js中方法与事件处理器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-30T20:37:12+08:00">
                2016-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-方法处理器"><a href="#一-方法处理器" class="headerlink" title="一.方法处理器"></a>一.方法处理器</h2><p>可以用 v-on 指令监听 DOM 事件：</p>
<pre><code>//.html
&lt;div id=&quot;example&quot;&gt;
  &lt;button v-on:click=&quot;greet&quot;&gt;Greet&lt;/button&gt;
&lt;/div&gt;
</code></pre><p>我们绑定了一个单击事件处理器到一个方法 greet。下面在 Vue 实例中定义这个方法：</p>
<pre><code>var vm = new Vue({
  el: &apos;#example&apos;,
  data: {
    name: &apos;Vue.js&apos;
  },
  //在methods对象中定义方法
  methods: {
    greet: function (event) {
      //方法内this指向vm
      alert(&apos;Hello &apos; + this.name + &apos;!&apos;)
      //event是原DOM事件
      alert(event.target.tagName)
    }
  }
})

// 也可以在 JavaScript 代码中调用方法
vm.greet() // -&gt; &apos;Hello Vue.js!&apos;
</code></pre><h2 id="二-内联语句处理器"><a href="#二-内联语句处理器" class="headerlink" title="二.内联语句处理器"></a>二.内联语句处理器</h2><p>除了直接绑定到一个方法，也可以用内联 JavaScript 语句：</p>
<pre><code>//.html
&lt;div id=&quot;example-2&quot;&gt;
  &lt;button v-on:click=&quot;say(&apos;hi&apos;)&quot;&gt;Say Hi&lt;/button&gt;
  &lt;button v-on:click=&quot;say(&apos;what&apos;)&quot;&gt;Say What&lt;/button&gt;
&lt;/div&gt;


//.js
var vm = new Vue({
  el: &apos;#example-2&apos;,
  methods: {
    say: function (msg) {
      alert(msg)
    }
  }
}) 
</code></pre><p>result:</p>
<pre><code>Hi

What
</code></pre><h2 id="三-事件修饰符"><a href="#三-事件修饰符" class="headerlink" title="三.事件修饰符"></a>三.事件修饰符</h2><p>在事件处理器中经常需要调用 event.preventDefault() 或 event.stopPropagation()。尽管我们在方法内可以轻松做到，不过让方法是纯粹的数据逻辑而不处理 DOM 事件细节会更好。</p>
<p>为了解决这个问题，Vue.js 为 v-on 提供两个 事件修饰符：.prevent 与 .stop。</p>
<pre><code>&lt;!-- 阻止单击事件冒泡 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 修饰符可以串联 --&gt;
&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;

&lt;!-- 只有修饰符 --&gt;
&lt;form v-on:submit.prevent&gt;&lt;/form&gt;
</code></pre><h2 id="四-按键修饰符"><a href="#四-按键修饰符" class="headerlink" title="四.按键修饰符"></a>四.按键修饰符</h2><p>在监听键盘事件时，我们经常需要检测 keyCode。Vue.js 允许为 v-on 添加按键修饰符：</p>
<pre><code>&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;
&lt;input v-on:keyup.13=&quot;submit&quot;&gt;
</code></pre><p>记住所有的 keyCode 比较困难，Vue.js 为最常用的按键提供别名：</p>
<pre><code>&lt;!-- 同上 --&gt;
&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;

&lt;!-- 缩写语法 --&gt;
&lt;input @keyup.enter=&quot;submit&quot;&gt;
</code></pre><h2 id="五-为什么在-HTML-中监听事件"><a href="#五-为什么在-HTML-中监听事件" class="headerlink" title="五.为什么在 HTML 中监听事件?"></a>五.为什么在 HTML 中监听事件?</h2><p>你可能注意到这种事件监听的方式违背了传统理念 “separation of concern”。不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护困难。实际上，使用 v-on 有几个好处：</p>
<ol>
<li><p>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。</p>
</li>
<li><p>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。</p>
</li>
<li><p>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/28/Vue-js中的表单控件绑定/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/28/Vue-js中的表单控件绑定/" itemprop="url">Vue.js中的表单控件绑定</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-28T20:28:57+08:00">
                2016-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>可以用 v-model 指令在表单控件元素上创建双向数据绑定。根据控件类型它自动选取正确的方法更新元素。尽管有点神奇，v-model 不过是语法糖，在用户输入事件中更新数据，以及特别处理一些极端例子。</p>
<p>1.text</p>
<pre><code>&lt;span&gt;Message is: {{ message }}&lt;/span&gt;
&lt;br&gt;
&lt;input type=&quot;text&quot; v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;
</code></pre><p><br><br>result:</p>
<p>Message is:</p>
 <input type="text" v-model="message" placeholder="edit me">

<p>2.multiline text</p>
<pre><code>&lt;span&gt;Multiline message is:&lt;/span&gt;
&lt;p&gt;{{ message }}&lt;/p&gt;
&lt;br&gt;
&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;
</code></pre><p>result:</p>
<p>Message is:</p>
 <textarea v-model="message" placeholder="add multiple lines"></textarea>

<p>3.Checkbox</p>
<p>单个勾选框，逻辑值：</p>
<pre><code>&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
&lt;label for=&quot;checkbox&quot;&gt;{{ checked }}&lt;/label&gt;
</code></pre><p> <input type="checkbox" id="checkbox" v-model="checked">false</p>
<p>4.多个勾选框，绑定到同一个数组：</p>
<pre><code>//.html
&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;
&lt;br&gt;
&lt;span&gt;Checked names: {{ checkedNames | json }}&lt;/span&gt;


//.js
new Vue({
  el: &apos;...&apos;,
  data: {
    checkedNames: []
  }
})
</code></pre><p>5.Radio</p>
<pre><code>&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;
&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;
&lt;br&gt;
&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;
&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;
&lt;br&gt;
&lt;span&gt;Picked: {{ picked }}&lt;/span&gt;
</code></pre><p> <input type="radio" id="one" value="One" v-model="picked"><br>    <label for="one">One</label><br>    <br><br>    <input type="radio" id="two" value="Two" v-model="picked"><br>    <label for="two">Two</label><br>    <br><br>    <span>Picked: </span></p>
<p>6.Select<br>单选：</p>
<pre><code>&lt;select v-model=&quot;selected&quot;&gt;
  &lt;option selected&gt;A&lt;/option&gt;
  &lt;option&gt;B&lt;/option&gt;
  &lt;option&gt;C&lt;/option&gt;
&lt;/select&gt;
&lt;span&gt;Selected: {{ selected }}&lt;/span&gt;
</code></pre><select v-model="selected"><br>  <option selected>A</option><br>  <option>B</option><br>  <option>C</option><br></select><br><br><br><span>Selected:[“A”]</span><br><br>7.绑定 value<br><br>对于单选按钮，勾选框及选择框选项，v-model 绑定的 value 通常是静态字符串（对于勾选框是逻辑值）：<br><br>    <!-- 当选中时，`picked` 为字符串 "a" --><br>    <input type="radio" v-model="picked" value="a"><br><br>    <!-- `toggle` 为 true 或 false --><br>    <input type="checkbox" v-model="toggle"><br><br>    <!-- 当选中时，`selected` 为字符串 "abc" --><br>    <select v-model="selected"><br>      <option value="abc">ABC</option><br>    </select>

<p>但是有时我们想绑定 value 到 Vue 实例的一个动态属性上，这时可以用 v-bind 实现，并且这个属性的值可以不是字符串。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/28/Vue-js中的条件渲染和列表渲染/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/28/Vue-js中的条件渲染和列表渲染/" itemprop="url">Vue.js中的条件渲染和列表渲染</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-28T20:25:41+08:00">
                2016-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-条件渲染"><a href="#一-条件渲染" class="headerlink" title="一.条件渲染"></a>一.条件渲染</h2><h3 id="1-v-if"><a href="#1-v-if" class="headerlink" title="1.v-if"></a>1.v-if</h3><p>例子：</p>
<pre><code>//.html
&lt;div id=&quot;vm&quot;&gt;  
    &lt;h1 v-if=&quot;ok&quot;&gt;ok&lt;/h1&gt;
    &lt;h1 v-else&gt;no&lt;/h1&gt;
&lt;/div&gt;



//.js
window.onload=function(){
  var vm = new Vue({
    el:&apos;#vm&apos;,
    data:{
        ok:true,
        no:false
        }
    });
}
</code></pre><p>result:</p>
<pre><code>ok
</code></pre><h3 id="2-template-v-if"><a href="#2-template-v-if" class="headerlink" title="2.template v-if"></a>2.template v-if</h3><p>因为 v-if 是一个指令，需要将它添加到一个元素上。但是如果我们想切换多个元素呢？此时我们可以把一个 <template> 元素当做包装元素，并在上面使用 v-if，最终的渲染结果不会包含它。</template></p>
<p>例子：</p>
<pre><code>&lt;template v-if=&quot;ok&quot;&gt;
  &lt;h1&gt;Title&lt;/h1&gt;
  &lt;p&gt;Paragraph 1&lt;/p&gt;
  &lt;p&gt;Paragraph 2&lt;/p&gt;
&lt;/template&gt;
</code></pre><h3 id="3-v-show"><a href="#3-v-show" class="headerlink" title="3.v-show"></a>3.v-show</h3><p>v-show指令的用法和v-if用法大体上一样</p>
<p>例子：</p>
<pre><code>&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;
</code></pre><p><strong>注意：</strong> 不同的是有 v-show 的元素会始终渲染并保持在 DOM 中。v-show 是简单的切换元素的 CSS 属性 display。</p>
<p>注意 v-show 不支持 <template> 语法。</template></p>
<h3 id="4-v-else"><a href="#4-v-else" class="headerlink" title="4.v-else"></a>4.v-else</h3><p>可以用 v-else 指令给 v-if 或 v-show 添加一个 “else 块”：</p>
<pre><code>&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;
      Sorry
&lt;/div&gt;
&lt;div v-else&gt;
      Not sorry
&lt;/div&gt;
</code></pre><p><strong>注意：</strong> v-else 元素必须立即跟在 v-if 或 v-show 元素的后面——否则它不能被识别。</p>
<h2 id="二-列表渲染"><a href="#二-列表渲染" class="headerlink" title="二.列表渲染"></a>二.列表渲染</h2><h3 id="1-v-for"><a href="#1-v-for" class="headerlink" title="1.v-for"></a>1.v-for</h3><p>a. 可以使用 v-for 指令基于一个数组渲染一个列表。这个指令使用特殊的语法，形式为 item in items，items 是数据数组，item 是当前数组元素的别名：</p>
<p>例：</p>
<pre><code>//.html
&lt;ul id=&quot;example-1&quot;&gt;
  &lt;li v-for=&quot;item in items&quot;&gt;
    {{ item.message }}
  &lt;/li&gt;
&lt;/ul&gt;



//.js
var example1 = new Vue({
  el: &apos;#example-1&apos;,
  data: {
    items: [
      { message: &apos;Foo&apos; },
      { message: &apos;Bar&apos; }
    ]
  }
})
</code></pre><p>result:</p>
<ul>
<li>Foo</li>
<li>Bar</li>
</ul>
<p>b. 也可以使用 v-for 遍历对象。除了 $index 之外，作用域内还可以访问另外一个特殊变量 $key。</p>
<p>例子：</p>
<pre><code>//.html
&lt;ul id=&quot;repeat-object&quot; class=&quot;demo&quot;&gt;
  &lt;li v-for=&quot;value in object&quot;&gt;
    {{ $key }} : {{ value }}
  &lt;/li&gt;
&lt;/ul&gt;



//.js
new Vue({
  el: &apos;#repeat-object&apos;,
  data: {
    object: {
      FirstName: &apos;John&apos;,
      LastName: &apos;Doe&apos;,
      Age: 30
    }
  }    
})
</code></pre><p>result:</p>
<ul>
<li>FirstName:John</li>
<li>lastname:Doe</li>
<li>Age:30</li>
</ul>
<p><strong>注意：</strong> 在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。</p>
<p>c. v-for也可以接收一个整数，此时它将重复模板数次。</p>
<pre><code>&lt;div&gt;
    &lt;span v-for=&quot;n in 10&quot;&gt;{{n}}&lt;/span&gt;
&lt;/div&gt;
</code></pre><p>result:</p>
<pre><code>0123456789
</code></pre><h3 id="2-template-v-for"><a href="#2-template-v-for" class="headerlink" title="2.template v-for"></a>2.template v-for</h3><p>类似于 template v-if，也可以将 v-for 用在 <template> 标签上，以渲染一个包含多个元素的块。例如：</template></p>
<pre><code>&lt;ul&gt;
  &lt;template v-for=&quot;item in items&quot;&gt;
    &lt;li&gt;{{ item.msg }}&lt;/li&gt;
    &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt;
  &lt;/template&gt;
&lt;/ul&gt;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/24/Node-js中的GET-POST请求/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/24/Node-js中的GET-POST请求/" itemprop="url">Node.js中的GET/POST请求</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-24T18:56:47+08:00">
                2016-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在很多场景中，我们的服务器都需要跟用户的浏览器打交道，如表单提交。<br>表单提交到服务器一般都使用GET/POST请求。</p>
</blockquote>
<h3 id="一-获取GET请求内容"><a href="#一-获取GET请求内容" class="headerlink" title="一.获取GET请求内容"></a>一.获取GET请求内容</h3><p>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。<br>node.js中url模块中的parse函数提供了这个功能。</p>
<pre><code>var http = require(&apos;http&apos;);
var url = require(&apos;url&apos;);
var util = require(&apos;util&apos;);

http.createServer(function(req, res){
    res.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;});
    res.end(util.inspect(url.parse(req.url, true)));
}).listen(3000);
</code></pre><p>在浏览器中访问<br><a href="http://localhost:3000/user?name=w3c&amp;email=w3c@w3cschool.cc" target="_blank" rel="external">http://localhost:3000/user?name=w3c&amp;email=w3c@w3cschool.cc</a> 然后查看返回结果为:</p>
<pre><code>Url {
  protocol: null,
  slashes: null,
  auth: null,
  host: null,
  port: null,
  hostname: null,
  hash: null,
  search: &apos;?name=w3c&amp;email=w3c@w3cschool.cc&apos;,
  query: { name: &apos;w3c&apos;, email: &apos;w3c@w3cschool.cc&apos; },
  pathname: &apos;/user&apos;,
  path: &apos;/user?name=w3c&amp;email=w3c@w3cschool.cc&apos;,
  href: &apos;/user?name=w3c&amp;email=w3c@w3cschool.cc&apos; }
</code></pre><h3 id="二-获取POST请求内容"><a href="#二-获取POST请求内容" class="headerlink" title="二.获取POST请求内容"></a>二.获取POST请求内容</h3><p>POST请求的内容全部的都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所有node.js默认是不会解析请求体的，当你需要的时候，需要手动来做。</p>
<pre><code>var http = require(&apos;http&apos;);
var querystring = require(&apos;querystring&apos;);
var util = require(&apos;util&apos;);

http.createServer(function(req, res){
    var post = &apos;&apos;;     //定义了一个post变量，用于暂存请求体的信息

    req.on(&apos;data&apos;, function(chunk){  

    //通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
    post += chunk;
    });

    req.on(&apos;end&apos;, function(){    
    //在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
    post = querystring.parse(post);
    res.end(util.inspect(post));
    });
}).listen(3000);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/24/Node-js中的RESTful/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/24/Node-js中的RESTful/" itemprop="url">Node.js中的RESTful</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-24T18:54:13+08:00">
                2016-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一-什么是-REST？"><a href="#一-什么是-REST？" class="headerlink" title="一.什么是 REST？"></a>一.什么是 REST？</h3><p>REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。</p>
<p>表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。</p>
<h3 id="二-HTTP-方法"><a href="#二-HTTP-方法" class="headerlink" title="二.HTTP 方法"></a>二.HTTP 方法</h3><p>以下为 REST 基本架构的四个方法：</p>
<ol>
<li>GET - 用于获取数据。</li>
<li>PUT - 用于添加数据。</li>
<li>DELETE - 用于删除数据。</li>
<li>POST - 用于更新或添加数据。</li>
</ol>
<h3 id="三-RESTful-Web-Services"><a href="#三-RESTful-Web-Services" class="headerlink" title="三.RESTful Web Services"></a>三.RESTful Web Services</h3><p>Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。</p>
<p>基于 REST 架构的 Web Services 即是 RESTful。</p>
<p>由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法。可以使用各种语言（比如 Java 程序、Perl、Ruby、Python、PHP 和 Javascript[包括 Ajax]）实现客户端。</p>
<p>RESTful Web 服务通常可以通过自动客户端或代表用户的应用程序访问。但是，这种服务的简便性让用户能够与之直接交互，使用它们的 Web 浏览器构建一个 GET URL 并读取返回的内容。</p>
<p>首先，创建一个 json 数据资源文件 users.json，内容如下：</p>
<pre><code>{
   &quot;user1&quot; : {
   &quot;name&quot; : &quot;mahesh&quot;,
   &quot;password&quot; : &quot;password1&quot;,
   &quot;profession&quot; : &quot;teacher&quot;,
   &quot;id&quot;: 1
},
&quot;user2&quot; : {
   &quot;name&quot; : &quot;suresh&quot;,
   &quot;password&quot; : &quot;password2&quot;,
   &quot;profession&quot; : &quot;librarian&quot;,
   &quot;id&quot;: 2
},
&quot;user3&quot; : {
   &quot;name&quot; : &quot;ramesh&quot;,
   &quot;password&quot; : &quot;password3&quot;,
   &quot;profession&quot; : &quot;clerk&quot;,
   &quot;id&quot;: 3
   }
}
</code></pre><p><strong>获取用户列表：</strong></p>
<p>以下代码，我们创建了 RESTful API listUsers，用于读取用户的信息列表， server.js 文件代码如下所示：</p>
<pre><code>var express = require(&apos;express&apos;);
var app = express();
var fs = require(&quot;fs&quot;);

app.get(&apos;/listUsers&apos;, function (req, res) {
    fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &apos;utf8&apos;, function (err, data) {
       console.log( data );
       res.end( data );
   });
})

var server = app.listen(8081, function () {

  var host = server.address().address
  var port = server.address().port

  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)

})
</code></pre><p>接下来执行以下命令：</p>
<pre><code>$ node server.js 
应用实例，访问地址为 http://0.0.0.0:8081
</code></pre><p>在浏览器中访问 <a href="http://127.0.0.1:8081/listUsers，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081/listUsers，结果如下所示：</a></p>
<pre><code>{
   &quot;user1&quot; : {
   &quot;name&quot; : &quot;mahesh&quot;,
   &quot;password&quot; : &quot;password1&quot;,
   &quot;profession&quot; : &quot;teacher&quot;,
   &quot;id&quot;: 1
},
&quot;user2&quot; : {
   &quot;name&quot; : &quot;suresh&quot;,
   &quot;password&quot; : &quot;password2&quot;,
   &quot;profession&quot; : &quot;librarian&quot;,
   &quot;id&quot;: 2
},
&quot;user3&quot; : {
   &quot;name&quot; : &quot;ramesh&quot;,
   &quot;password&quot; : &quot;password3&quot;,
   &quot;profession&quot; : &quot;clerk&quot;,
   &quot;id&quot;: 3
}
}
</code></pre><p><strong>添加用户</strong></p>
<p>以下代码，我们创建了 RESTful API addUser， 用于添加新的用户数据，server.js 文件代码如下所示：</p>
<pre><code>var express = require(&apos;express&apos;);
var app = express();
var fs = require(&quot;fs&quot;);

//添加的新用户数据
var user = {
  &quot;user4&quot; : {
  &quot;name&quot; : &quot;mohit&quot;,
  &quot;password&quot; : &quot;password4&quot;,
  &quot;profession&quot; : &quot;teacher&quot;,
  &quot;id&quot;: 4
 }
}

app.get(&apos;/addUser&apos;, function (req, res) {
// 读取已存在的数据
fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &apos;utf8&apos;, function (err, data) {
   data = JSON.parse( data );
   data[&quot;user4&quot;] = user[&quot;user4&quot;];
   console.log( data );
   res.end( JSON.stringify(data));
});
})

var server = app.listen(8081, function () {

  var host = server.address().address
  var port = server.address().port
  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)

})
</code></pre><p>接下来执行以下命令：</p>
<pre><code>$ node server.js 
 应用实例，访问地址为 http://0.0.0.0:8081
</code></pre><p>在浏览器中访问 <a href="http://127.0.0.1:8081/addUser，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081/addUser，结果如下所示：</a></p>
<pre><code>{ user1:
   { name: &apos;mahesh&apos;,
     password: &apos;password1&apos;,
     profession: &apos;teacher&apos;,
     id: 1 },
  user2:
   { name: &apos;suresh&apos;,
     password: &apos;password2&apos;,
     profession: &apos;librarian&apos;,
     id: 2 },
  user3:
   { name: &apos;ramesh&apos;,
     password: &apos;password3&apos;,
     profession: &apos;clerk&apos;,
     id: 3 },
  user4:
       { name: &apos;mohit&apos;,
     password: &apos;password4&apos;,
     profession: &apos;teacher&apos;,
     id: 4 } 
}
</code></pre><p><strong>显示用户详情</strong></p>
<p>以下代码，我们创建了 RESTful API :id（用户id）， 用于读取指定用户的详细信息，server.js 文件代码如下所示：</p>
<pre><code>var express = require(&apos;express&apos;);
var app = express();
var fs = require(&quot;fs&quot;);

app.get(&apos;/:id&apos;, function (req, res) {
// 首先我们读取已存在的用户
fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &apos;utf8&apos;, function (err, data) {
   data = JSON.parse( data );
   var user = data[&quot;user&quot; + req.params.id] 
   console.log( user );
   res.end( JSON.stringify(user));
 });
})

var server = app.listen(8081, function () {

   var host = server.address().address
   var port = server.address().port
   console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)

})
</code></pre><p>接下来执行以下命令：</p>
<pre><code>$ node server.js 
应用实例，访问地址为 http://0.0.0.0:8081
</code></pre><p>在浏览器中访问 <a href="http://127.0.0.1:8081/2，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081/2，结果如下所示：</a></p>
<pre><code>{
   &quot;name&quot;:&quot;suresh&quot;,
   &quot;password&quot;:&quot;password2&quot;,
   &quot;profession&quot;:&quot;librarian&quot;,
   &quot;id&quot;:2
}
</code></pre><p><strong>删除用户</strong></p>
<p>以下代码，我们创建了 RESTful API deleteUser， 用于删除指定用户的详细信息，以下实例中，用户 id 为 2，server.js 文件代码如下所示：</p>
<pre><code>var express = require(&apos;express&apos;);
var app = express();
var fs = require(&quot;fs&quot;);

var id = 2;

app.get(&apos;/deleteUser&apos;, function (req, res) {

   // First read existing users.
   fs.readFile( __dirname + &quot;/&quot; + &quot;users.json&quot;, &apos;utf8&apos;, function (err, data) {
       data = JSON.parse( data );
       delete data[&quot;user&quot; + 2];

       console.log( data );
       res.end( JSON.stringify(data));
   });
})

var server = app.listen(8081, function () {

  var host = server.address().address
  var port = server.address().port
  console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)

})
</code></pre><p>接下来执行以下命令：</p>
<pre><code>$ node server.js 
应用实例，访问地址为 http://0.0.0.0:8081
</code></pre><p>在浏览器中访问 <a href="http://127.0.0.1:8081/deleteUser，结果如下所示：" target="_blank" rel="external">http://127.0.0.1:8081/deleteUser，结果如下所示：</a></p>
<pre><code>{ user1:
   { name: &apos;mahesh&apos;,
     password: &apos;password1&apos;,
     profession: &apos;teacher&apos;,
     id: 1 },
  user3:
   { name: &apos;ramesh&apos;,
     password: &apos;password3&apos;,
     profession: &apos;clerk&apos;,
     id: 3 } 
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/23/Node-js中的events模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/23/Node-js中的events模块/" itemprop="url">Node.js中的events模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-23T21:16:55+08:00">
                2016-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> <strong>注意：</strong></p>
<ol>
<li><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p>
</li>
<li><p>Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p>
</li>
</ol>
<hr>
<h3 id="一-EventEmitter类"><a href="#一-EventEmitter类" class="headerlink" title="一.EventEmitter类"></a>一.EventEmitter类</h3><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。可以通过require(“events”);来访问该模块。</p>
<pre><code>// 引入 events 模块
var events = require(&apos;events&apos;);
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
</code></pre><p>EventEmitter 对象如果在实例化时发生错误，会触发 ‘error’ 事件。当添加新的监听器时，’newListener’ 事件会触发，当监听器被移除时，’removeListener’ 事件被触发。</p>
<h3 id="二-EventEmitter-的用法："><a href="#二-EventEmitter-的用法：" class="headerlink" title="二.EventEmitter 的用法："></a>二.EventEmitter 的用法：</h3><pre><code>//event.js 文件
var EventEmitter = require(&apos;events&apos;).EventEmitter; 
var event = new EventEmitter(); 
event.on(&apos;some_event&apos;, function() { 
    console.log(&apos;some_event 事件触发&apos;); 
}); 
setTimeout(function() { 
    event.emit(&apos;some_event&apos;); 
}, 1000); 
</code></pre><p>执行结果如下：<br>运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p>
<pre><code>$ node event.js 
some_event 事件触发
</code></pre><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p>
<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。<br>让我们以下面的例子解释这个过程：</p>
<pre><code>//event.js 文件
var events = require(&apos;events&apos;); 
var emitter = new events.EventEmitter(); 
emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { 
    console.log(&apos;listener1&apos;, arg1, arg2); 
}); 
emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { 
    console.log(&apos;listener2&apos;, arg1, arg2); 
}); 
emitter.emit(&apos;someEvent&apos;, &apos;arg1 参数&apos;, &apos;arg2 参数&apos;); 
</code></pre><p>执行以上代码，运行的结果如下：</p>
<pre><code>$ node event.js 
listener1 arg1 参数 arg2 参数
listener2 arg1 参数 arg2 参数
</code></pre><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。<br>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p>
<h3 id="三-EventEmitter-的属性"><a href="#三-EventEmitter-的属性" class="headerlink" title="三.EventEmitter 的属性"></a>三.EventEmitter 的属性</h3><p> EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p>
<ol>
<li><p>addListener(event, listener)<br>为指定事件添加一个监听器到监听器数组的尾部。</p>
</li>
<li><p>on(event, listener)<br>为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</p>
<pre><code>erver.on(&apos;connection&apos;, function (stream) {
    console.(&apos;someone connected!&apos;);
});
</code></pre></li>
<li><p>once(event, listener)<br>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</p>
<pre><code>server.once(&apos;connection&apos;, function (stream){
    console.log(&apos;Ah, we have our first user!&apos;);
});
</code></pre></li>
<li><p>removeListener(event, listener)<br>移除指定事件的某个监听器，监听器 必须是该事件已经注册过的监听器。</p>
<pre><code>var callback = function(stream) {
       console.log(&apos;someone connected!&apos;);
};
server.on(&apos;connection&apos;, callback);
// ...
server.removeListener(&apos;connection&apos;, callback);
</code></pre></li>
<li><p>removeAllListeners([event])<br>移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</p>
</li>
<li><p>setMaxListeners(n)<br>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</p>
</li>
<li><p>listeners(event)<br>返回指定事件的监听器数组。</p>
</li>
<li><p>emit(event, [arg1], [arg2], […])<br>按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</p>
</li>
</ol>
<h3 id="四-继承-EventEmitter"><a href="#四-继承-EventEmitter" class="headerlink" title="四.继承 EventEmitter"></a>四.继承 EventEmitter</h3><ul>
<li>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</li>
</ul>
<ul>
<li>为什么要这样做呢？原因有两点：<br>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。<br>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2016/10/21/Node-js中的fs模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="yuxuan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于禤的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/21/Node-js中的fs模块/" itemprop="url">Node.js中的fs模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-21T22:14:51+08:00">
                2016-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>Node.js内置的fs模块就是文件系统模块，负责读写文件。和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。</p>
</blockquote>
<h3 id="一-同步读文件"><a href="#一-同步读文件" class="headerlink" title="一.同步读文件"></a>一.同步读文件</h3><ol>
<li><p>创建一个文件 input.txt ，内容如下：</p>
<pre><code>你好，我是于禤。
Hello!my name is yuxuan.
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);

var data = fs.readFileSync(&apos;input.txt&apos;);

console.log(data.toString());
console.log(&quot;程序执行结束!&quot;);
</code></pre></li>
<li><p>以上代码执行结果如下：</p>
<pre><code>$ node main.js

 你好，我是于禤。
Hello!my name is yuxuan.
程序执行结束!
</code></pre></li>
</ol>
<h3 id="二-异步读文件"><a href="#二-异步读文件" class="headerlink" title="二.异步读文件"></a>二.异步读文件</h3><ol>
<li><p>创建一个文件 input.txt ，内容如下：</p>
<pre><code>你好，我是于禤。
    Hello!my name is yuxuan.
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);

fs.readFile(&apos;input.txt&apos;, function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});

console.log(&quot;程序执行结束!&quot;);
</code></pre></li>
<li><p>以上代码执行结果如下：</p>
<pre><code> 程序执行结束!
 你好，我是于禤。
Hello!my name is yuxuan.
</code></pre></li>
</ol>
<h3 id="三-写文件（fs-writeFile-）"><a href="#三-写文件（fs-writeFile-）" class="headerlink" title="三.写文件（fs.writeFile()）"></a>三.写文件（fs.writeFile()）</h3><ol>
<li><p>创建一个空文件 output.txt</p>
</li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&apos;fs&apos;);

var data = &apos;Hello, Node.js&apos;;
fs.writeFile(&apos;output.txt&apos;, data, function (err) {
    if (err) {
        console.log(err);
    } else {
        console.log(&apos;ok.&apos;);
    }
});
</code></pre></li>
<li><p>执行结果：空文件 output.txt里的内容变为Hello, Node.js。<br>writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。</p>
</li>
<li><p>和readFile()类似，writeFile()也有一个同步方法，叫writeFileSync()：</p>
<pre><code>var fs = require(&apos;fs&apos;);
var data = &apos;Hello, Node.js&apos;;
fs.writeFileSync(&apos;output.txt&apos;, data);
</code></pre></li>
</ol>
<h3 id="四-获取文件的详细信息（fs-stat-）"><a href="#四-获取文件的详细信息（fs-stat-）" class="headerlink" title="四.获取文件的详细信息（fs.stat()）"></a>四.获取文件的详细信息（fs.stat()）</h3><ol>
<li><p>创建一个文件 input.txt ，内容如下：</p>
<pre><code>你好，我是于禤。
Hello!my name is yuxuan.
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&apos;fs&apos;);

fs.stat(&apos;input.txt&apos;, function (err, stat) {
if (err) {
    console.log(err);
} else {
    // 是否是文件:
    console.log(&apos;isFile: &apos; + stat.isFile());
    // 是否是目录:
    console.log(&apos;isDirectory: &apos; + stat.isDirectory());
    if (stat.isFile()) {
        // 文件大小:
        console.log(&apos;size: &apos; + stat.size);
        // 创建时间, Date对象:
        console.log(&apos;birth time: &apos; + stat.birthtime);
        // 修改时间, Date对象:
        console.log(&apos;modified time: &apos; + stat.mtime);
        }
 }
});
</code></pre></li>
<li><p>运行结果如下：</p>
<pre><code>isFile: true
isDirectory: false
size: 51
birth time: Thu Oct 20 2016 13:40:21 GMT+0800 (中国标准时间)
modified time: Thu Oct 20 2016 14:04:41 GMT+0800 (中国标准时间)
</code></pre></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="yuxuan" />
          <p class="site-author-name" itemprop="name">yuxuan</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuxuan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">本站访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">本站浏览量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
