<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>于禤的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="于禤的博客">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="于禤的博客">
<meta property="og:locale">
<meta property="article:author" content="yuxuan">
<meta property="article:tag" content="yuxuan">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="于禤的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">于禤的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学习+记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-React和Vue的比较" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/05/08/React%E5%92%8CVue%E7%9A%84%E6%AF%94%E8%BE%83/" class="article-date">
  <time class="dt-published" datetime="2020-05-08T04:08:49.000Z" itemprop="datePublished">2020-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React/">React</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/05/08/React%E5%92%8CVue%E7%9A%84%E6%AF%94%E8%BE%83/">React和Vue的比较</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在面对自学前端三大主流框架（React、Vue、Angular）选择时，相信不少人选择了Vue。</p>
<p>从事前端工作三年有余，大四实习的时候选择了Vue框架，仅仅是因为Vue学习成本较低和入门相对容易些。毕业后进入现在的公司用的是React，就开始了React的学习探索直到现在。</p>
</blockquote>
<h4 id="React和Vue的使用比较："><a href="#React和Vue的使用比较：" class="headerlink" title="React和Vue的使用比较："></a>React和Vue的使用比较：</h4><p>​    相比Vue来说，React提供的API的确较少，比如Vue中的v-if，v-for之类的指令在React中需要自行用js实现，这也让React能够更大程度的发挥js的灵活性，能更自由的组合js，可以用js的if实现v-if，js的for实现v-for。React的概念简洁（自由度高），Vue的使用便利（提供现成的范式），React相对Vue规矩的多，这是因为其目标并非写更少的代码，而是追求条理更好理解，这种极高的代码规范在大型项目上是非常可贵的，可以减少不稳定因素的影响，很适合团队开发。</p>
<p>​    React的一大优势是把用户界面抽象成一个个组件，如按钮组件Button，对话框组件Dialog，日期组件Calendar。开发者通过组合这些组件，最终得到功能丰富、可交互的页面。通过引入JSX语法，使得编写组件简单快速，同时保证组件结构清晰。</p>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>React起源于Facebook的内部项目，用来架设Instagram网站（Instagram在中国大陆简称<strong>ins</strong>，是Facebook公司旗下一款免费提供在线图片及视频分享的社交网站），并于 2013年 5 月开源。</p>
<p>React是用于构建用户界面的JS框架。因此react只负责解决view层的渲染。</p>
<p>React拥有较高的性能，代码逻辑简单，越来越多的人开始关注和使用。</p>
<p>React做了什么？</p>
<ol>
<li><p>Virtual Dom模型</p>
</li>
<li><p>生命周期管理</p>
</li>
<li><p>setState机制</p>
</li>
<li><p>diff算法</p>
</li>
<li><p>React patch、事件系统</p>
</li>
<li><p>React的 Virtual Dom模型（virtual dom 实际上是对实际Dom的一个抽象，是一个js对象。react所有的表层操作实际上是在操作virtual dom。）</p>
</li>
<li><p>diff算法用于计算出两个virtual dom的差异，是react中开销最大的地方。</p>
<p>传统diff算法通过循环递归对比差异，算法复杂度为O(n3)。</p>
<p>react diff算法制定了三条策略，将算法复杂度从 O(n3)降低到O(n)。</p>
<p>WebUI中DOM节点跨节点的操作特别少，可以忽略不计。<br>拥有相同类的组件会拥有相似的DOM结构。拥有不同类的组件会生成不同的DOM结构。<br>同一层级的子节点，可以根据唯一的ID来区分。<br>针对这三个策略，react diff实施的具体策略是:</p>
<p><strong>diff对树进行分层比较，只对比两棵树同级别的节点。</strong>跨层级移动节点，将会导致节点删除，重新插入，无法复用。<br>diff对组件进行类比较，类相同的递归diff子节点，不同的直接销毁重建。diff对同一层级的子节点进行处理时，会根据key进行简要的复用。两棵树中存在相同key的节点时，只会移动节点。<br>另外，在对比同一层级的子节点时:</p>
<p>diff算法会以新树的第一个子节点作为起点遍历新树，寻找旧树中与之相同的节点。</p>
<p>如果节点存在，则移动位置。如果不存在，则新建一个节点。</p>
<p>在这过程中，维护了一个字段lastIndex，这个字段表示已遍历的所有新树子节点在旧树中最大的index。<br>在移动操作时，只有旧index小于lastIndex的才会移动。</p>
<p>这个顺序优化方案实际上是基于一个假设，大部分的列表操作应该是保证列表基本有序的。<br>可以推倒倒序的情况下，子节点列表diff的算法复杂度为O(n2)</p>
</li>
</ol>
<p>特点：</p>
<ol>
<li>声明式设计：React采用声明范式，可以轻松描述应用。</li>
<li>高效：React通过对DOM的模拟，最大限度的减少与DOM的交互。</li>
<li>灵活：React可以与已知的库或框架（<strong>个人觉得框架是要求你按照它提供的规则去写代码， 而库是多个工具函数的集合</strong>。）很好的配合。</li>
</ol>
<p>优点：</p>
<ol>
<li><p>速度快：在UI渲染过程中，React通过在虚拟DOM中的微操作来实现对实际DOM的局部更新。</p>
</li>
<li><p>跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。</p>
</li>
<li><p>模块化：为你程序编写独立的模块化UI组件，这样当某个或某些组件出现问题是，可以方便地进行隔离。</p>
</li>
<li><p>单向数据流：Flux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。</p>
</li>
<li><p>同构、纯粹的javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。</p>
</li>
<li><p>兼容性好：比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。</p>
</li>
</ol>
<p>缺点：</p>
<p>React本身只是一个V（view）而已，并不是一个完整的框架，所以如果是大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和Flux才能写大型应用。</p>
<h4 id="React性能优化方案"><a href="#React性能优化方案" class="headerlink" title="React性能优化方案"></a>React性能优化方案</h4><p>由于react中性能主要耗费在于update阶段的diff算法，因此性能优化也主要针对diff算法。</p>
<ol>
<li>减少diff算法触发次数<br>减少diff算法触发次数实际上就是减少update流程的次数。<br>正常进入update流程有三种方式：</li>
<li>setState<br>setState机制在正常运行时，由于批更新策略，已经降低了update过程的触发次数。<br>因此，setState优化主要在于非批更新阶段中(timeout/Promise回调)，减少setState的触发次数。<br>常见的业务场景即处理接口回调时，无论数据处理多么复杂，保证最后只调用一次setState。</li>
<li>父组件render<br>父组件的render必然会触发子组件进入update阶段（无论props是否更新）。此时最常用的优化方案即为shouldComponentUpdate方法。<br>最常见的方式为进行this.props和this.state的浅比较来判断组件是否需要更新。或者直接使用PureComponent，原理一致。<br>需要注意的是，父组件的render函数如果写的不规范，将会导致上述的策略失效。</li>
<li>正确使用diff算法<br>不使用跨层级移动节点的操作。<br>对于条件渲染多个节点时，尽量采用隐藏等方式切换节点，而不是替换节点。<br>尽量避免将后面的子节点移动到前面的操作，当节点数量较多时，会产生一定的性能问题。</li>
</ol>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>Vue是尤雨溪编写的一个构建数据驱动的Web界面的库，准确来说不是一个框架，它聚焦在V（view）视图层。</p>
<p>基本原理：</p>
<ol>
<li>建立虚拟DOM Tree，通过document.createDocumentFragment()，遍历指定根节点内部节点，根据、v-model等规则进行compile；</li>
<li>通过Object.defineProperty()进行数据变化拦截；</li>
<li>截取到的数据变化，通过发布者-订阅者模式，触发Watcher，从而改变虚拟DOM中的具体数据；</li>
<li>通过改变虚拟DOM元素值，从而改变最后渲染dom树的值，完成双向绑定。完成数据的双向绑定在于Object.defineProperty()</li>
</ol>
<p>特点：</p>
<ol>
<li><p>轻量级的框架</p>
</li>
<li><p>双向数据绑定</p>
</li>
<li><p>指令</p>
</li>
<li><p>插件化</p>
</li>
</ol>
<p>优点：</p>
<ol>
<li><p>简单：官方文档很清晰，比Angular简单易学。</p>
</li>
<li><p>快速：异步批处理方式更新DOM。</p>
</li>
<li><p>组合：用解耦的、可复用的组件组合你的应用程序。</p>
</li>
<li><p>紧凑：~18kbmin+gzip，且无依赖。</p>
</li>
<li><p>强大：表达式无需声明依赖的可推导属性(computedproperties)。</p>
</li>
<li><p>对模块友好：可以通过NPM、Bower或Duo安装，不强迫你所有的代码都遵循Angular的各种规定，使用场景更加灵活。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>新生儿：Vue.js是一个新的项目，没有angular那么成熟。</p>
</li>
<li><p>影响度不是很大：google了一下，有关于Vue.js多样性或者说丰富性少于其他一些有名的库</p>
</li>
<li><p>不支持IE8。</p>
</li>
</ol>
<h3 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h3><p>Angular是一款优秀的前端JS框架，已经被用于Google的多款产品当中。</p>
<p>特点：</p>
<ol>
<li><p>良好的应用程序结构</p>
</li>
<li><p>双向数据绑定</p>
</li>
<li><p>指令</p>
</li>
<li><p>HTML模板</p>
</li>
<li><p>可嵌入、注入和测试</p>
</li>
</ol>
<p>优点：</p>
<ol>
<li><p>模板功能强大丰富，自带了极其丰富的angular指令。</p>
</li>
<li><p>是一个比较完善的前端框架，包含服务，模板，数据双向绑定，模块化，路由，过滤器，依赖注入等所有功能；3.自定义指令，自定义指令后可以在项目中多次使用。</p>
</li>
<li><p>ng模块化比较大胆的引入了Java的一些东西（依赖注入），能够很容易的写出可复用的代码，对于敏捷开发的团队来说非常有帮助。</p>
</li>
<li><p>angularjs是互联网巨人谷歌开发，这也意味着他有一个坚实的基础和社区支持。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>angular入门很容易但深入后概念很多,学习中较难理解。</p>
</li>
<li><p>文档例子非常少,官方的文档基本只写了api,一个例子都没有,很多时候具体怎么用都是google来的,或直接问misko,angular的作者。</p>
</li>
<li><p>对IE6/7兼容不算特别好,就是可以用jQuery自己手写代码解决一些。</p>
</li>
<li><p>指令的应用的最佳实践教程少,angular其实很灵活,如果不看一些作者的使用原则,很容易写出四不像的代码,例如js中还是像jQuery的思想有很多dom操作。</p>
</li>
<li><p>DI依赖注入如果代码压缩需要显示声明。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/08/React%E5%92%8CVue%E7%9A%84%E6%AF%94%E8%BE%83/" data-id="cklkumnhz004fd0uuf49n8h2o" data-title="React和Vue的比较" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-找出字符串中重复次数最多的字符和次数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/15/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E6%AC%A1%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2020-04-15T13:48:37.000Z" itemprop="datePublished">2020-04-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/15/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E6%AC%A1%E6%95%B0/">找出字符串中重复次数最多的字符和次数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p> 记录一种解题思路……</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;aaafdaewrebdafdasfdsafdsafb&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStrSum</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      @思路</span></span><br><span class="line"><span class="comment">      /1.首先遍历字符串每一数据</span></span><br><span class="line"><span class="comment">      /2.把找到的数据放进对象中</span></span><br><span class="line"><span class="comment">      /3.if判断是否有重复数据,如果有就+1,没有就等于1</span></span><br><span class="line"><span class="comment">      /4.str.charAt(i) 返回当前下标对应的字符 列如let str=abc; str.charAt(1)获取的是b</span></span><br><span class="line"><span class="comment">      /5.把保存对象遍历,进行比对,取最大的值出来打印</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[str.charAt(i)]) &#123;</span><br><span class="line">      obj[str.charAt(i)]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj[str.charAt(i)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> number;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[key] &gt; sum) &#123;</span><br><span class="line">      sum = obj[key];</span><br><span class="line">      number = key;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(number + <span class="string">&quot;出现了=====&quot;</span> + sum + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">getStrSum(str);</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/15/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E6%AC%A1%E6%95%B0/" data-id="cklkumniu0089d0uu82ydf2t5" data-title="找出字符串中重复次数最多的字符和次数" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Websocket" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/15/Websocket/" class="article-date">
  <time class="dt-published" datetime="2020-03-15T13:03:10.000Z" itemprop="datePublished">2020-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/15/Websocket/">Websocket</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p>
<p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
</blockquote>
<h3 id="传统轮询-Traditional-Polling"><a href="#传统轮询-Traditional-Polling" class="headerlink" title="传统轮询(Traditional Polling)"></a>传统轮询(Traditional Polling)</h3><p>当前Web应用中较常见的一种持续通信方式，通常采取 setInterval 或者 setTimeout 实现。例如如果我们想要定时获取并刷新页面上的数据，可以结合Ajax写出如下实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.get(<span class="string">&quot;/path/to/server&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, status</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>

<p>上面的程序会每隔10秒向服务器请求一次数据，并在数据到达后存储。这个实现方法通常可以满足简单的需求，然而同时也存在着很大的缺陷：在网络情况不稳定的情况下，服务器从接收请求、发送请求到客户端接收请求的总时间有可能超过10秒，而请求是以10秒间隔发送的，这样会导致接收的数据到达先后顺序与发送顺序不一致。于是出现了采用 setTimeout 的轮询方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">poll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        $.get(<span class="string">&quot;/path/to/server&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, status</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data);</span><br><span class="line">            <span class="comment">// 发起下一次请求</span></span><br><span class="line">            poll();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, <span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序首先设置10秒后发起请求，当数据返回后再隔10秒发起第二次请求，以此类推。这样的话虽然无法保证两次请求之间的时间间隔为固定值，但是可以保证到达数据的顺序。</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>程序在每次请求时都会新建一个HTTP请求，然而并不是每次都能返回所需的新数据。当同时发起的请求达到一定数目时，会对服务器造成较大负担。</p>
<h3 id="长轮询-long-poll"><a href="#长轮询-long-poll" class="headerlink" title="长轮询(long poll)"></a>长轮询(long poll)</h3><p>客户端发送一个request后，服务器拿到这个连接，如果有消息，才返回response给客户端。没有消息，就一直不返回response。之后客户端再次发送request, 重复上次的动作。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>http协议的特点是服务器不能主动联系客户端，只能由客户端发起。它的被动性预示了在完成双向通信时需要不停的连接或连接一直打开，这就需要服务器快速的处理速度或高并发的能力，是非常消耗资源的。</p>
<h3 id="什么是websocket"><a href="#什么是websocket" class="headerlink" title="什么是websocket?"></a>什么是websocket?</h3><p>WebSocket是HTML5的一个新协议，它允许服务端向客户端传递信息，实现浏览器和客户端双工通信</p>
<p>因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问,轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p>
<h3 id="Websocket的特点"><a href="#Websocket的特点" class="headerlink" title="Websocket的特点:"></a>Websocket的特点:</h3><p>服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p>
<ul>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 </li>
<li>建立在TCP协议基础之上，和http协议同属于应用层</li>
<li>数据格式比较轻量，性能开销小，通信高效。 </li>
<li>可以发送文本，也可以发送二进制数据。 </li>
<li>没有同源限制，客户端可以与任意服务器通信</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL,如ws://localhost:8023</li>
</ul>
<h3 id="跨平台的WebSocket通信库socket-io"><a href="#跨平台的WebSocket通信库socket-io" class="headerlink" title="跨平台的WebSocket通信库socket.io"></a>跨平台的WebSocket通信库socket.io</h3><p>跨平台的WebSocket通信库，具有前后端一致的API，可以触发和响应自定义的事件。socket.io最核心的两个api就是emit 和 on了 ，服务端和客户端都有这两个api。通过 emit 和 on可以实现服务器与客户端之间的双向通信。</p>
<ul>
<li>emit ：发射一个事件，第一个参数为事件名，第二个参数为要发送的数据，第三个参数为回调函数（如需对方接受到信息后立即得到确认时，则需要用到回调函数）。 </li>
<li>on ：监听一个 emit 发射的事件，第一个参数为要监听的事件名，第二个参数为回调函数，用来接收对方发来的数据，该函数的第一个参数为接收的数据。</li>
</ul>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)();</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socketio  = <span class="built_in">require</span>(<span class="string">&quot;socket.io&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(app)</span><br><span class="line"><span class="keyword">const</span> io = socketio(server)</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// WebSocket 连接服务器</span></span><br><span class="line">io.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">socket</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//// 所有的事件触发响应都写在这里</span></span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        count++</span><br><span class="line">        <span class="comment">//向建立该连接的客户端发送消息</span></span><br><span class="line">        socket.emit(<span class="string">&#x27;mynameEv&#x27;</span>, &#123; <span class="attr">name</span>:<span class="string">&quot;你我贷&quot;</span>+count&#125;)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">    <span class="comment">//监听客户端发送信息</span></span><br><span class="line">    socket.on(<span class="string">&#x27;yournameEv&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.sendfile(__dirname + <span class="string">&#x27;/index.html&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 启用3000端口</span></span><br><span class="line">server.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;div id=<span class="string">&quot;myname&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">   &lt;script src=<span class="string">&quot;http://localhost:3000/socket.io/socket.io.js&quot;</span>/&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">      <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">const</span> socket = io.connect(<span class="string">&#x27;http://localhost:3000&#x27;</span>)</span><br><span class="line">      socket.on(<span class="string">&#x27;mynameEv&#x27;</span>, <span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">document</span>.getElementById(<span class="string">&quot;myname&quot;</span>).innerHTML = data.name;</span><br><span class="line">         <span class="built_in">console</span>.log(data.name)</span><br><span class="line">         <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                count++</span><br><span class="line">                socket.emit(<span class="string">&#x27;yournameEv&#x27;</span>, &#123; <span class="attr">name</span>:<span class="string">&quot;飞旋&quot;</span>+count&#125;)</span><br><span class="line">         &#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/03/15/Websocket/" data-id="cklkumni9005id0uu3eqn5tg2" data-title="Websocket" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-前后端接口交互ajax、axios、fetch" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/03/01/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E4%BA%A4%E4%BA%92ajax%E3%80%81axios%E3%80%81fetch/" class="article-date">
  <time class="dt-published" datetime="2020-03-01T07:36:23.000Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/03/01/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E4%BA%A4%E4%BA%92ajax%E3%80%81axios%E3%80%81fetch/">数据请求之ajax、axios、fetch</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>对于搭建大型项目前后端分离是必须的，前后端分离的好处不用多说。前端工作一个重要的技能就是对接后台给的接口，从最初的Ajax，到目前比较火的fetch和axios，因为axios可以拦截请求和响应，转换请求数据和响应数据，并对响应回来的内容自动转换为json类型的数据等优势，个人比较喜欢使用axios。</p>
</blockquote>
<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p>Ajax是一种可以在浏览器和服务器之间使用异步数据传输（HTTP请求）的技术。使用它可以让页面请求少量的数据，而不用刷新整个页面。而传统的页面（不使用Ajax）要刷新部分内容，必须重载整个网页页面。它基于的是XMLHttpRequest（XHR）。这是一个比较粗糙的API，不符合关注分离的设计原则（Separation of Concerns），配置和使用都不是那么友好。</p>
<h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>fetch是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局<code>fetch()</code>方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。fetch不是ajax的进一步封装，而是原生js。</p>
<p>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p>
<p>旧版本的浏览器不支持Promise，需要使用polyfill es6-promise。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">res: Response</span>): <span class="title">Promise</span>&lt;<span class="title">any</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (res.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.json()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> handleError(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildQueryString</span>(<span class="params">params: &#123;&#125; | <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> qs = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (params) &#123;</span><br><span class="line">    qs = <span class="built_in">Object</span>.keys(params)</span><br><span class="line">      .filter(<span class="function"><span class="params">k</span> =&gt;</span> params[k] !== <span class="literal">undefined</span> &amp;&amp; params[k] !== <span class="literal">null</span>)</span><br><span class="line">      .map(<span class="function"><span class="params">k</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(k)&#125;</span>=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(params[k])&#125;</span>`</span>)</span><br><span class="line">      .join(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> qs === <span class="string">&#x27;&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">`?<span class="subst">$&#123;qs&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> getWith(path: <span class="built_in">string</span>, <span class="attr">params</span>: &#123;&#125; | <span class="literal">undefined</span>, handler): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> token = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">`<span class="subst">$&#123;path&#125;</span><span class="subst">$&#123;buildQueryString(params)&#125;</span>`</span></span><br><span class="line">    <span class="keyword">return</span> fetch(url, &#123;</span><br><span class="line">      method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        Authorization: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).then(handler)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> get(path, <span class="attr">params</span>: &#123;&#125; | <span class="literal">undefined</span>): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.getWith(path, params, handleResponse)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里</li>
<li>更好更方便的写法</li>
<li>更加底层，提供的API丰富（request, response）</li>
<li>脱离了XHR，是ES规范里新的实现方式</li>
</ul>
<p>缺点：</p>
<ul>
<li>fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</li>
<li>fetch默认不会带cookie，需要添加配置项</li>
<li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li>
<li>fetch没有办法原生监测请求的进度，而XHR可以。</li>
</ul>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>axios是一个基于promise的HTTP库，支持promise的所有API。</p>
<p>axios也是对原生XHR的一种封装，不过是Promise实现版本，用于浏览器和node.js的http客户端</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">.post(url, data, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">     Accept: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">     <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>优缺点：</p>
<ul>
<li>从 node.js 创建 http 请求。</li>
<li>支持 Promise API。</li>
<li>提供了一些并发请求的接口（重要，方便了很多的操作）。</li>
<li>在浏览器中创建 XMLHttpRequests。</li>
<li>在 node.js 则创建 http 请求。（自动性强）</li>
<li>支持 Promise API。</li>
<li>支持拦截请求和响应。</li>
<li>转换请求和响应数据。</li>
<li>取消请求。</li>
<li>自动转换 JSON 数据。</li>
<li>客户端支持防止CSRF。</li>
<li>客户端支持防御 XSRF。</li>
</ul>
<h4 id="为什么要用axios"><a href="#为什么要用axios" class="headerlink" title="为什么要用axios?"></a>为什么要用axios?</h4><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p>
<ul>
<li>从浏览器中创建 XMLHttpRequest</li>
<li>从 node.js 发出 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换JSON数据</li>
<li>客户端支持防止CSRF/XSRF（防止CSRF:就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。）</li>
<li>axios既提供了并发的封装，也没有fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/03/01/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E4%BA%A4%E4%BA%92ajax%E3%80%81axios%E3%80%81fetch/" data-id="cklkumnip007hd0uuc0kleulu" data-title="数据请求之ajax、axios、fetch" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JS中深拷贝的方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/20/JS%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-02-20T14:23:57.000Z" itemprop="datePublished">2020-02-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/20/JS%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E6%B3%95/">JS中深拷贝的方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><strong>浅拷贝：</strong>复制变量的地址，所有地址对象都指向一个数据，而且所有地址对象都能修改这个数据。</p>
<p><strong>深拷贝</strong>：复制变量的值。对于非基本类型的变量，可以通过<strong>递归</strong>至基本类型后，再复制。数组中可以使用slice和concat方法来进行深拷贝。</p>
<p>递归是什么？ 如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
</blockquote>
<h3 id="1、使用递归的方式实现深拷贝"><a href="#1、使用递归的方式实现深拷贝" class="headerlink" title="1、使用递归的方式实现深拷贝"></a>1、使用递归的方式实现深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用递归的方式实现数组、对象的深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone1</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//判断拷贝的要进行深拷贝的是数组还是对象，是数组的话进行数组拷贝，对象的话进行对象拷贝</span></span><br><span class="line">  <span class="keyword">var</span> objClone = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="comment">//进行深拷贝的不能为空，并且是对象或者是</span></span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">          objClone[key] = deepClone1(obj[key]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          objClone[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、通过-JSON-对象实现深拷贝"><a href="#2、通过-JSON-对象实现深拷贝" class="headerlink" title="2、通过 JSON 对象实现深拷贝"></a>2、通过 JSON 对象实现深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过js的内置对象JSON来进行数组对象的深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone2</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _obj = <span class="built_in">JSON</span>.stringify(obj),</span><br><span class="line">    objClone = <span class="built_in">JSON</span>.parse(_obj);</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON对象实现深拷贝的一些问题，无法实现对对象中方法的深拷贝</p>
<h3 id="3、通过jQuery的extend方法实现深拷贝"><a href="#3、通过jQuery的extend方法实现深拷贝" class="headerlink" title="3、通过jQuery的extend方法实现深拷贝"></a>3、通过jQuery的extend方法实现深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> newArray = $.extend(<span class="literal">true</span>,[],array);<span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="4、Object-assign-拷贝"><a href="#4、Object-assign-拷贝" class="headerlink" title="4、Object.assign()拷贝"></a>4、Object.assign()拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。1</span><br></pre></td></tr></table></figure>

<h3 id="5、lodash函数库实现深拷贝"><a href="#5、lodash函数库实现深拷贝" class="headerlink" title="5、lodash函数库实现深拷贝"></a>5、lodash函数库实现深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lodash很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/20/JS%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E6%B3%95/" data-id="cklkumnh7001hd0uu387mak57" data-title="JS中深拷贝的方法" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Javascript中数组的深拷贝和浅拷贝" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/19/Javascript%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" class="article-date">
  <time class="dt-published" datetime="2020-02-19T07:01:48.000Z" itemprop="datePublished">2020-02-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/19/Javascript%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">JavaScript中数组的深拷贝和浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>最近开发的时候遇到了数组拷贝的问题，数组a是原数组，数组b是拷贝的数组，当操作数组b的时候，数组a也发生了变化， 然后想到了数组深拷贝和浅拷贝。</p>
</blockquote>
<h2 id="堆内存和栈内存？"><a href="#堆内存和栈内存？" class="headerlink" title="堆内存和栈内存？"></a>堆内存和栈内存？</h2><p>JS中变量分基本数据类型和引用数据类型。</p>
<p>基本数据： String，Number，Boolean，Undefined，Null</p>
<p>引用数据类型：Object，Function，Array等。</p>
<p><strong>栈（Stack）又名堆栈</strong>，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。</p>
<p>如果是基础类型，那栈中存的是数据本身。</p>
<p>如果是对象类型，那栈中存的是堆中对象的引用。</p>
<p>栈内存的运行效率比堆内存高，栈内存的空间比堆内存小。</p>
<p>基本数据的值和地址都存在栈内存中。</p>
<p>引用类型的值存放在栈内存中，引用类型的地址存放在堆内存中。</p>
<h2 id="深拷贝与浅拷贝？"><a href="#深拷贝与浅拷贝？" class="headerlink" title="深拷贝与浅拷贝？"></a><strong>深拷贝与浅拷贝</strong>？</h2><p><strong>浅拷贝：</strong>复制变量的地址，所有地址对象都指向一个数据，而且所有地址对象都能修改这个数据。</p>
<p><strong>深拷贝</strong>：复制变量的值。对于非基本类型的变量，则递归至基本类型变量后，再复制。数组中可以使用slice和concat方法来进行深拷贝。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/19/Javascript%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/" data-id="cklkumnhj002jd0uu2ix2hya7" data-title="JavaScript中数组的深拷贝和浅拷贝" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-事件冒泡和事件捕获" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/17/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7/" class="article-date">
  <time class="dt-published" datetime="2020-02-17T01:10:39.000Z" itemprop="datePublished">2020-02-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/17/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7/">事件冒泡和事件捕获</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-DOM事件"><a href="#1-DOM事件" class="headerlink" title="1. DOM事件"></a>1. DOM事件</h3><p>DOM级别一共可以分为4个级别：DOM0级，DOM1级，DOM2级和DOM3级，<br>而DOM事件分为3个级别：DOM0级事件处理，DOM2级事件处理和DOM3级事件处理。</p>
<p><strong>事件</strong>：指可以被 JavaScript 侦测到的行为。即鼠标点击、页面或图像载入、鼠标悬浮于页面的某个热点之上、在表单中选取输入框、确认表单、键盘按键等操作。事件通常与函数配合使用，当事件发生时函数才会执行。</p>
<p><strong>事件名称</strong>：click/mouseover/blur(“不带on”)</p>
<p><strong>事件处理程序</strong>(事件侦听器：**<code>addEventListener</code>**)：响应某个事件的函数 。</p>
<p><strong>事件处理程序函数名称</strong>：onclick/onmouseove/onblur</p>
<h2 id="2-事件流"><a href="#2-事件流" class="headerlink" title="2. 事件流"></a>2. 事件流</h2><p><strong>事件流</strong>：指从页面中接收事件的顺序,也可理解为事件在页面中传播的顺序。</p>
<p>IE事件流是事件冒泡，Netscape的事件流是事件捕获。</p>
<p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标阶段接收到事件被触发。最后的阶段是冒泡阶段可以在这个阶段对事件做出响应。</p>
<h3 id="3-事件冒泡"><a href="#3-事件冒泡" class="headerlink" title="3. 事件冒泡"></a>3. 事件冒泡</h3><p><strong>冒泡</strong>： IE的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。即从下到上，从目标触发的元素逐级向上传播，直到window对象。</p>
<h3 id="4-阻止事件冒泡"><a href="#4-阻止事件冒泡" class="headerlink" title="4. 阻止事件冒泡"></a>4. 阻止事件冒泡</h3><ol>
<li><p>给子级加 event.stopPropagation( )</p>
</li>
<li><p>在事件处理函数中返回 false</p>
<p>但是这两种方式是有区别的。<code>return false</code> 不仅阻止了事件往上冒泡，而且阻止了事件本身(默认事件)。<code>event.stopPropagation()</code>则只阻止事件往上冒泡，不阻止事件本身。</p>
</li>
<li><p>event.target==event.currentTarget，让触发事件的元素等于绑定事件的元素，也可以阻止事件冒泡；</p>
</li>
<li><p>阻止默认事件：event.preventDefault( )</p>
</li>
</ol>
<h3 id="5-事件捕获"><a href="#5-事件捕获" class="headerlink" title="5. 事件捕获"></a>5. 事件捕获</h3><p><strong>捕获</strong>： Netscape团队提出了另一种事件流叫做事件捕获。事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件，事件捕获的用意在于在事件到达预定目标之前捕获它。</p>
<h3 id="6-阻止事件捕获"><a href="#6-阻止事件捕获" class="headerlink" title="6. 阻止事件捕获"></a>6. 阻止事件捕获</h3><ol>
<li><p>通过设置<code>addEventListener</code>的第三个参数可以决定事件是否在捕获阶段触发。</p>
</li>
<li><p>stopPropagation()方法既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止处于目标阶段。</p>
</li>
<li><p>使用DOM3级新增事件stopImmediatePropagation()方法来阻止事件捕获，另外此方法还可以阻止事件冒泡。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(event, <span class="function"><span class="keyword">function</span>, <span class="title">useCapture</span>)</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">event</span>：必须。字符串，指定事件名。</span></span><br><span class="line"><span class="function">	   注意: 不要使用 &quot;<span class="title">on</span>&quot; 前缀。 例如，使用 &quot;<span class="title">click</span>&quot; ,而不是使用 &quot;<span class="title">onclick</span>&quot;。</span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span>：当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， &quot;<span class="title">click</span>&quot; 事件属于 		   <span class="title">MouseEvent</span>(<span class="params">鼠标事件</span>) 对象。</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">useCapture</span>：<span class="title">true</span> - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）</span></span></span><br><span class="line"><span class="function"><span class="function">			<span class="title">false</span>- <span class="title">false</span>- 默认。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）</span></span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/17/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7/" data-id="cklkumnij006od0uucsa6cw5d" data-title="事件冒泡和事件捕获" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JS中数据类型的判断" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/13/JS%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD/" class="article-date">
  <time class="dt-published" datetime="2020-02-13T13:44:37.000Z" itemprop="datePublished">2020-02-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/13/JS%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD/">JS数据类型的判断</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul>
<li>可以判断数据类型，它返回表示数据类型的字符串（返回结果只能包括number,boolean,string,function,object,undefined）；</li>
<li>可以使用typeof判断变量是否存在（如if(typeof a!=”undefined”){…}）；</li>
<li>Typeof 运算符的问题是无论引用的对象是什么类型    它都返回object</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span>  [<span class="number">1</span>,<span class="number">2</span>] <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> /\s/ <span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>原理 因为A instanceof B 可以判断A是不是B的实例，返回一个布尔值，由构造类型判断出数据类型</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(date <span class="keyword">instanceof</span> <span class="built_in">Date</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(fn <span class="keyword">instanceof</span> <span class="built_in">Function</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Object下的toString-call-方法"><a href="#Object下的toString-call-方法" class="headerlink" title="Object下的toString.call()方法"></a>Object下的toString.call()方法</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="number">123</span>)); <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="string">&#x27;123&#x27;</span>)); <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">undefined</span>)); <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">true</span>)); <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(&#123;&#125;)); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call([])); <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">//[object Function]</span></span><br></pre></td></tr></table></figure>

<h3 id="根据对象的contructor判断："><a href="#根据对象的contructor判断：" class="headerlink" title="根据对象的contructor判断："></a>根据对象的contructor判断：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;数据类型判断&#39; -  constructor);</span><br><span class="line">console.log(arr.constructor &#x3D;&#x3D;&#x3D; Array); &#x2F;&#x2F;true</span><br><span class="line">console.log(date.constructor &#x3D;&#x3D;&#x3D; Date); &#x2F;&#x2F;true</span><br><span class="line">console.log(fn.constructor &#x3D;&#x3D;&#x3D; Function); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/13/JS%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD/" data-id="cklkumnh6001dd0uuamwaesrj" data-title="JS数据类型的判断" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-前端页面优化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/02/13/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2020-02-13T02:24:53.000Z" itemprop="datePublished">2020-02-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/02/13/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/">前端页面优化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>对于前后端分离的项目，前后端的优化都是很重要的。后台优化服务器，排查SQL命令等。前后台优化都是相辅相成的，后台的响应速度快，前端的页面加载速度也要快速，用户体验才能更好。</p>
</blockquote>
<p>​    优化HTTP请求数，由于用户浏览的往往是局部网页，所以只加载用户可视范围内的资源，就会减少一些不必要的请求，也会减少浏览器加载资源的消耗。页面优化主要包括网络加载类、页面渲染类、CSS优化类、JavaScript执行类、缓存类、图片类、架构协议类等几类；</p>
<ol>
<li><p><strong>图片延迟加载</strong></p>
<p>延长加载也称懒加载。我们常用的是react-lazyload(Lazyload your Components, Images or anything matters the performance.) 来进行图片的预加载和延迟加载处理。前面有<a target="_blank" rel="noopener" href="https://yxyuxuan.github.io/2019/08/26/%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD/">懒加载和预加载</a>的文章。</p>
</li>
<li><p><strong>定义图片大小限制</strong></p>
<p> 加载的单张图片一般建议不超过30KB，避免大图片加载时间长而阻塞页面其他资源的下载，因此推荐10KB以内，如果用户上传的图片过大，建议设置告警系统，帮助我们观察了解整个网站的图片流量情况，做出进一步的改善。</p>
</li>
<li><p><strong>预加载资源</strong>（图片和数据请求）</p>
<p>但有一些需求是希望尽量少出现延迟加载带来的“等待”过程，这时就可以预加载资源。</p>
</li>
<li><p><strong>资源合并</strong></p>
<p>可以把多个脚本合并到一个js文件内，然后统一引用它就能减少http请求。</p>
<p>通用的CSS样式可以合并到一个文件里。</p>
<p>通用的组件和方法可以提取出来。</p>
</li>
<li><p><strong>引用优化</strong></p>
<p>引用css放在<head>内，引用js放在</body>结束标签前。</p>
<p>css加载是异步的，更早的加载出样式就能更早呈现出页面。<br>js放在尾部，防止浏览器加载js而阻塞页面，造成页面“白屏”现象。</p>
</li>
<li><p><strong>单独域名存放资源</strong></p>
<p>如果有条件的话，我们还可以启用额外的服务器，域名来存放资源</p>
<p>这样能减少主域名的HTTP请求数，让主服务器更快响应请求<br>还能减少主域名的cookie请求</p>
</li>
<li><p><strong>离线存储</strong></p>
<p>在移动端应用的比较多<br>它和缓存不同，它设置好之后，离线也能访问，无论用户刷新或者新窗口，链接等等</p>
</li>
<li><p><strong>本地存储localStorage</strong></p>
<p>本地存储数据一直是网页端的弱项，在没有HTML5的localStorage前，用cookie可以保存一点数据<br>但付出的代价很大，cookie能保存的数据很少，并且它会伴随着每一次请求一起发送</p>
<p>localStorage就好多了，默认5MB的大小，除非用户手动清除，否则一直不过期，就连IE8浏览器都支持</p>
<p>这里要注意，localStorage和cookie一样受到跨域的限制<br>可以使用domain控制</p>
</li>
<li><p><strong>CSS3替换js动画</strong></p>
<p>在js中，我们实现动画，就是利用定时器循环改变dom元素的属性来达到动画效果<br>但是许多属性更改之后会造成浏览器重绘，增加性能消耗</p>
<p>css3在动画效率上面有增强，浏览器会单独处理css3动画，不占用js主线程，还可以硬件加速</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/13/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/" data-id="cklkumnip007kd0uufmcd2yep" data-title="前端页面优化" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-js中的apply、call和bind" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/01/15/js%E4%B8%AD%E7%9A%84apply%E3%80%81call%E5%92%8Cbind/" class="article-date">
  <time class="dt-published" datetime="2020-01-15T05:59:45.000Z" itemprop="datePublished">2020-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/01/15/js%E4%B8%AD%E7%9A%84apply%E3%80%81call%E5%92%8Cbind/">js中的apply、call和bind</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>apply()、call()和bind()方法都是Function.prototype对象中的方法，而所有的函数都是Function的实例。这三个方法的用法非常相似，将函数绑定到上下文中，即用来改变函数中this的指向。</p>
</blockquote>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;lucy&#x27;</span>&#125;;<span class="comment">// 注意这是一个普通对象，它不是Person的实例</span></span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">  <span class="title">showName</span>: <span class="title">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;lily&#x27;</span>);</span><br><span class="line">person.showName(); <span class="comment">// lily</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用apply</span></span><br><span class="line">person.showName.apply(obj,[param1, param2, param3]); <span class="comment">// lucy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用call</span></span><br><span class="line">person.showName.call(obj,param1, param2, param3); <span class="comment">// lucy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用bind</span></span><br><span class="line"><span class="keyword">let</span> bind = person.showName.bind(obj); <span class="comment">// 返回一个函数</span></span><br><span class="line">bind(); <span class="comment">// lucy</span></span><br></pre></td></tr></table></figure>

<p>apply和call都是直接执行函数调用。</p>
<p>bind是绑定，执行需要再次调用。</p>
<p>apply和call的区别是从第二个参数开始，apply接受数组作为参数，而call是接受逗号分隔的无限多个参数列表。</p>
<h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ol>
<li><h5 id="将伪数组转化为数组（含有length属性的对象，函数的参数的类数组对象arguments）"><a href="#将伪数组转化为数组（含有length属性的对象，函数的参数的类数组对象arguments）" class="headerlink" title="将伪数组转化为数组（含有length属性的对象，函数的参数的类数组对象arguments）"></a>将伪数组转化为数组（含有length属性的对象，函数的参数的类数组对象arguments）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//含有length属性的对象</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="number">0</span>: <span class="string">&quot;1ily&quot;</span>,</span><br><span class="line">	<span class="number">1</span>: <span class="string">&quot;women&quot;</span>,</span><br><span class="line">	<span class="number">2</span>: <span class="number">20</span>,</span><br><span class="line">	length: <span class="number">3</span> <span class="comment">// 一定要有length属性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(obj)); <span class="comment">// [&quot;1ily&quot;, &quot;women&quot;, 20]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的参数的类数组对象arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>利用call和apply做继承</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;      </span><br><span class="line">    <span class="built_in">this</span>.name = name;      </span><br><span class="line">    <span class="built_in">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);      </span><br><span class="line">    &#125;      </span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;    </span><br><span class="line">    Animal.call(<span class="built_in">this</span>, name);    </span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"><span class="comment">// Animal.call(this) 的意思就是使用this对象代替Animal对象，那么</span></span><br><span class="line"><span class="comment">// Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">&quot;1ily&quot;</span>);     </span><br><span class="line">cat.showName();   <span class="comment">//1ily</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>求数组中的最大值和最小值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">89</span>,<span class="number">46</span>]</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr)<span class="comment">//89</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>,arr)<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数组的追加</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"><span class="keyword">let</span> total = [].push.apply(arr1, arr2) <span class="comment">//6</span></span><br><span class="line"><span class="comment">// arr1 [1, 2, 3, 8,9,10]</span></span><br><span class="line"><span class="comment">// arr2 [8,9,10]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>总结</strong></p>
<p>三者都可以改变函数的this对象指向。</p>
<p>三者第一个参数都是this要指向的对象，如果如果没有这个参数，默认指向全局window。</p>
<p>三者都可以传参，但是apply是数组，而call是有顺序的传入。</p>
<p>bind 是返回对应函数，便于稍后调用。apply 、call 则是立即执行 。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/15/js%E4%B8%AD%E7%9A%84apply%E3%80%81call%E5%92%8Cbind/" data-id="cklkumnif0067d0uue2pu9p9x" data-title="js中的apply、call和bind" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; zurück</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/4/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%AD%A3%E5%88%99/">正则</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AJAX/" rel="tag">AJAX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ant-Design/" rel="tag">Ant Design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Backbone/" rel="tag">Backbone</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/" rel="tag">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/" rel="tag">GitHub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/" rel="tag">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mobx/" rel="tag">Mobx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SASS/" rel="tag">SASS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue-js/" rel="tag">Vue.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/less/" rel="tag">less</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99/" rel="tag">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AJAX/" style="font-size: 10px;">AJAX</a> <a href="/tags/Ant-Design/" style="font-size: 10px;">Ant Design</a> <a href="/tags/Backbone/" style="font-size: 10px;">Backbone</a> <a href="/tags/CSS/" style="font-size: 17.5px;">CSS</a> <a href="/tags/CSS3/" style="font-size: 13.75px;">CSS3</a> <a href="/tags/Git/" style="font-size: 13.75px;">Git</a> <a href="/tags/GitHub/" style="font-size: 10px;">GitHub</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Mobx/" style="font-size: 10px;">Mobx</a> <a href="/tags/Node-js/" style="font-size: 16.25px;">Node.js</a> <a href="/tags/React/" style="font-size: 18.75px;">React</a> <a href="/tags/SASS/" style="font-size: 10px;">SASS</a> <a href="/tags/Vue-js/" style="font-size: 12.5px;">Vue.js</a> <a href="/tags/hexo/" style="font-size: 12.5px;">hexo</a> <a href="/tags/less/" style="font-size: 10px;">less</a> <a href="/tags/webpack/" style="font-size: 11.25px;">webpack</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 10px;">微信小程序</a> <a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 10px;">正则</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 12.5px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15px;">网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/25/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/02/21/Backbone%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B0%8F%E7%BB%93/">Backbone框架的小结</a>
          </li>
        
          <li>
            <a href="/2020/10/25/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">斐波那契数列</a>
          </li>
        
          <li>
            <a href="/2020/09/16/JS%E4%B8%AD%E7%9A%84sort%E5%92%8ClocaleCompare%E6%8E%92%E5%BA%8F/">JS中的sort和localeCompare排序</a>
          </li>
        
          <li>
            <a href="/2020/09/16/JS%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/">JS中的任务队列</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 yuxuan<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>