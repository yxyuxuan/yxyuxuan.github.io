<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="yuxuan" />


    
    


<meta property="og:type" content="website">
<meta property="og:title" content="萱儿的博客">
<meta property="og:url" content="https://yoursite.com/index.html">
<meta property="og:site_name" content="萱儿的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="萱儿的博客">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="萱儿的博客" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">


    <style> .article { opacity: 0;} </style>


<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>萱儿的博客</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: true,
        isPost: false,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/2.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">yuxuan</a></h1>
        </hgroup>

        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="https://yxyuxuan.github.io/My-Resume/我的简历/index.html">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/">GitHub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://github.com/yxyuxuan/yxyuxuan.github.io">我的GitHub</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">yuxuan</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/2.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">yuxuan</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="https://yxyuxuan.github.io/My-Resume/我的简历/index.html">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap">
  
    <article id="post-Node-js中的events模块" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/10/23/Node-js中的events模块/" class="article-date">
      <time datetime="2016-10-23T13:16:55.000Z" itemprop="datePublished">2016-10-23</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/23/Node-js中的events模块/">Node.js中的events模块</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p> <strong>注意：</strong></p>
<ol>
<li><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p>
</li>
<li><p>Node.js里面的许多对象都会分发事件：一个net.Server对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p>
</li>
</ol>
<hr>
<h3 id="一-EventEmitter类"><a href="#一-EventEmitter类" class="headerlink" title="一.EventEmitter类"></a>一.EventEmitter类</h3><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。可以通过require(“events”);来访问该模块。</p>
<pre><code>// 引入 events 模块
var events = require(&apos;events&apos;);
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();
</code></pre><p>EventEmitter 对象如果在实例化时发生错误，会触发 ‘error’ 事件。当添加新的监听器时，’newListener’ 事件会触发，当监听器被移除时，’removeListener’ 事件被触发。</p>
<h3 id="二-EventEmitter-的用法："><a href="#二-EventEmitter-的用法：" class="headerlink" title="二.EventEmitter 的用法："></a>二.EventEmitter 的用法：</h3><pre><code>//event.js 文件
var EventEmitter = require(&apos;events&apos;).EventEmitter; 
var event = new EventEmitter(); 
event.on(&apos;some_event&apos;, function() { 
    console.log(&apos;some_event 事件触发&apos;); 
}); 
setTimeout(function() { 
    event.emit(&apos;some_event&apos;); 
}, 1000); 
</code></pre><p>执行结果如下：<br>运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p>
<pre><code>$ node event.js 
some_event 事件触发
</code></pre><p>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p>
<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。<br>让我们以下面的例子解释这个过程：</p>
<pre><code>//event.js 文件
var events = require(&apos;events&apos;); 
var emitter = new events.EventEmitter(); 
emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { 
    console.log(&apos;listener1&apos;, arg1, arg2); 
}); 
emitter.on(&apos;someEvent&apos;, function(arg1, arg2) { 
    console.log(&apos;listener2&apos;, arg1, arg2); 
}); 
emitter.emit(&apos;someEvent&apos;, &apos;arg1 参数&apos;, &apos;arg2 参数&apos;); 
</code></pre><p>执行以上代码，运行的结果如下：</p>
<pre><code>$ node event.js 
listener1 arg1 参数 arg2 参数
listener2 arg1 参数 arg2 参数
</code></pre><p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。<br>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p>
<h3 id="三-EventEmitter-的属性"><a href="#三-EventEmitter-的属性" class="headerlink" title="三.EventEmitter 的属性"></a>三.EventEmitter 的属性</h3><p> EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p>
<ol>
<li><p>addListener(event, listener)<br>为指定事件添加一个监听器到监听器数组的尾部。</p>
</li>
<li><p>on(event, listener)<br>为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</p>
<pre><code>erver.on(&apos;connection&apos;, function (stream) {
    console.(&apos;someone connected!&apos;);
});
</code></pre></li>
<li><p>once(event, listener)<br>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</p>
<pre><code>server.once(&apos;connection&apos;, function (stream){
    console.log(&apos;Ah, we have our first user!&apos;);
});
</code></pre></li>
<li><p>removeListener(event, listener)<br>移除指定事件的某个监听器，监听器 必须是该事件已经注册过的监听器。</p>
<pre><code>var callback = function(stream) {
       console.log(&apos;someone connected!&apos;);
};
server.on(&apos;connection&apos;, callback);
// ...
server.removeListener(&apos;connection&apos;, callback);
</code></pre></li>
<li><p>removeAllListeners([event])<br>移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</p>
</li>
<li><p>setMaxListeners(n)<br>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</p>
</li>
<li><p>listeners(event)<br>返回指定事件的监听器数组。</p>
</li>
<li><p>emit(event, [arg1], [arg2], […])<br>按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</p>
</li>
</ol>
<h3 id="四-继承-EventEmitter"><a href="#四-继承-EventEmitter" class="headerlink" title="四.继承 EventEmitter"></a>四.继承 EventEmitter</h3><ul>
<li>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</li>
</ul>
<ul>
<li>为什么要这样做呢？原因有两点：<br>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。<br>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/">Node.js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Node-js中的fs模块" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/10/21/Node-js中的fs模块/" class="article-date">
      <time datetime="2016-10-21T14:14:51.000Z" itemprop="datePublished">2016-10-21</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/21/Node-js中的fs模块/">Node.js中的fs模块</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>Node.js内置的fs模块就是文件系统模块，负责读写文件。和所有其它JavaScript模块不同的是，fs模块同时提供了异步和同步的方法。</p>
</blockquote>
<h3 id="一-同步读文件"><a href="#一-同步读文件" class="headerlink" title="一.同步读文件"></a>一.同步读文件</h3><ol>
<li><p>创建一个文件 input.txt ，内容如下：</p>
<pre><code>你好，我是于禤。
Hello!my name is yuxuan.
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);

var data = fs.readFileSync(&apos;input.txt&apos;);

console.log(data.toString());
console.log(&quot;程序执行结束!&quot;);
</code></pre></li>
<li><p>以上代码执行结果如下：</p>
<pre><code>$ node main.js

 你好，我是于禤。
Hello!my name is yuxuan.
程序执行结束!
</code></pre></li>
</ol>
<h3 id="二-异步读文件"><a href="#二-异步读文件" class="headerlink" title="二.异步读文件"></a>二.异步读文件</h3><ol>
<li><p>创建一个文件 input.txt ，内容如下：</p>
<pre><code>你好，我是于禤。
    Hello!my name is yuxuan.
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);

fs.readFile(&apos;input.txt&apos;, function (err, data) {
    if (err) return console.error(err);
    console.log(data.toString());
});

console.log(&quot;程序执行结束!&quot;);
</code></pre></li>
<li><p>以上代码执行结果如下：</p>
<pre><code> 程序执行结束!
 你好，我是于禤。
Hello!my name is yuxuan.
</code></pre></li>
</ol>
<h3 id="三-写文件（fs-writeFile-）"><a href="#三-写文件（fs-writeFile-）" class="headerlink" title="三.写文件（fs.writeFile()）"></a>三.写文件（fs.writeFile()）</h3><ol>
<li><p>创建一个空文件 output.txt</p>
</li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&apos;fs&apos;);

var data = &apos;Hello, Node.js&apos;;
fs.writeFile(&apos;output.txt&apos;, data, function (err) {
    if (err) {
        console.log(err);
    } else {
        console.log(&apos;ok.&apos;);
    }
});
</code></pre></li>
<li><p>执行结果：空文件 output.txt里的内容变为Hello, Node.js。<br>writeFile()的参数依次为文件名、数据和回调函数。如果传入的数据是String，默认按UTF-8编码写入文本文件，如果传入的参数是Buffer，则写入的是二进制文件。回调函数由于只关心成功与否，因此只需要一个err参数。</p>
</li>
<li><p>和readFile()类似，writeFile()也有一个同步方法，叫writeFileSync()：</p>
<pre><code>var fs = require(&apos;fs&apos;);
var data = &apos;Hello, Node.js&apos;;
fs.writeFileSync(&apos;output.txt&apos;, data);
</code></pre></li>
</ol>
<h3 id="四-获取文件的详细信息（fs-stat-）"><a href="#四-获取文件的详细信息（fs-stat-）" class="headerlink" title="四.获取文件的详细信息（fs.stat()）"></a>四.获取文件的详细信息（fs.stat()）</h3><ol>
<li><p>创建一个文件 input.txt ，内容如下：</p>
<pre><code>你好，我是于禤。
Hello!my name is yuxuan.
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&apos;fs&apos;);

fs.stat(&apos;input.txt&apos;, function (err, stat) {
if (err) {
    console.log(err);
} else {
    // 是否是文件:
    console.log(&apos;isFile: &apos; + stat.isFile());
    // 是否是目录:
    console.log(&apos;isDirectory: &apos; + stat.isDirectory());
    if (stat.isFile()) {
        // 文件大小:
        console.log(&apos;size: &apos; + stat.size);
        // 创建时间, Date对象:
        console.log(&apos;birth time: &apos; + stat.birthtime);
        // 修改时间, Date对象:
        console.log(&apos;modified time: &apos; + stat.mtime);
        }
 }
});
</code></pre></li>
<li><p>运行结果如下：</p>
<pre><code>isFile: true
isDirectory: false
size: 51
birth time: Thu Oct 20 2016 13:40:21 GMT+0800 (中国标准时间)
modified time: Thu Oct 20 2016 14:04:41 GMT+0800 (中国标准时间)
</code></pre></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/">Node.js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-用Node-js实现HTTP服务器程序" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/10/21/用Node-js实现HTTP服务器程序/" class="article-date">
      <time datetime="2016-10-21T12:57:26.000Z" itemprop="datePublished">2016-10-21</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/21/用Node-js实现HTTP服务器程序/">用Node.js实现HTTP服务器程序</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>最近在学习Node.js的基本模块,现用Node.js实现一个HTTP服务器程序</p>
</blockquote>
<p><strong>注意：</strong></p>
<ol>
<li><p>要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。</p>
</li>
<li><p>request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息；</p>
</li>
<li><p>response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。</p>
</li>
</ol>
<hr>
<h3 id="一-让我们先了解下-Node-js-应用是由哪几部分组成的："><a href="#一-让我们先了解下-Node-js-应用是由哪几部分组成的：" class="headerlink" title="一.让我们先了解下 Node.js 应用是由哪几部分组成的："></a>一.让我们先了解下 Node.js 应用是由哪几部分组成的：</h3><ol>
<li><p><strong>引入 required 模块：</strong>我们可以使用 require 指令来载入 Node.js 模块。</p>
</li>
<li><p><strong>创建服务器</strong>：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</p>
</li>
<li><p><strong>接收请求与响应请求:</strong>服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。</p>
</li>
</ol>
<h3 id="二-Node-js实现一个HTTP服务器程序的步骤："><a href="#二-Node-js实现一个HTTP服务器程序的步骤：" class="headerlink" title="二.Node.js实现一个HTTP服务器程序的步骤："></a>二.Node.js实现一个HTTP服务器程序的步骤：</h3><h4 id="1-引入requried模块："><a href="#1-引入requried模块：" class="headerlink" title="1. 引入requried模块："></a>1. 引入requried模块：</h4><p>我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p>
<pre><code>var http = require(&quot;http&quot;);
</code></pre><h3 id="2-创建服务器，接收请求与响应请求："><a href="#2-创建服务器，接收请求与响应请求：" class="headerlink" title="2. 创建服务器，接收请求与响应请求："></a>2. 创建服务器，接收请求与响应请求：</h3><p>接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8080 端口。 函数通过 request, response 参数来接收和响应数据。实例如下：</p>
<pre><code>// 创建http server，并传入回调函数:
var server = http.createServer(function (request, response) {

      // 将HTTP响应200写入response, 同时设置Content-Type: text/html:
      response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/html&apos;});

      // 将HTTP响应的HTML内容写入response:
      response.end(&apos;&lt;h1&gt;Hello world!&lt;/h1&gt;&apos;);
});

// 让服务器监听8080端口:
server.listen(8080,&apos;127.0.0.1&apos;);

//// 终端打印如下信息
console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;);
</code></pre><h3 id="3-在命令提示符下运行该程序，可以看到以下输出："><a href="#3-在命令提示符下运行该程序，可以看到以下输出：" class="headerlink" title="3. 在命令提示符下运行该程序，可以看到以下输出："></a>3. 在命令提示符下运行该程序，可以看到以下输出：</h3><pre><code>$ node hello.js 
Server is running at http://127.0.0.1:8080/
</code></pre><h3 id="4-不要关闭命令提示符，直接打开浏览器输入http-127-0-0-1-8080，即可看到服务器响应的内容："><a href="#4-不要关闭命令提示符，直接打开浏览器输入http-127-0-0-1-8080，即可看到服务器响应的内容：" class="headerlink" title="4. 不要关闭命令提示符，直接打开浏览器输入http://127.0.0.1:8080，即可看到服务器响应的内容："></a>4. 不要关闭命令提示符，直接打开浏览器输入<a href="http://127.0.0.1:8080，即可看到服务器响应的内容：" target="_blank" rel="external">http://127.0.0.1:8080，即可看到服务器响应的内容：</a></h3><pre><code>Hello world!
</code></pre><h2 id="三-分析Node-js-的-HTTP-服务器"><a href="#三-分析Node-js-的-HTTP-服务器" class="headerlink" title="三.分析Node.js 的 HTTP 服务器"></a>三.分析Node.js 的 HTTP 服务器</h2><ul>
<li>第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。</li>
</ul>
<ul>
<li>接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/">Node.js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Node-js中的Stream模块" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/10/20/Node-js中的Stream模块/" class="article-date">
      <time datetime="2016-10-20T13:12:32.000Z" itemprop="datePublished">2016-10-20</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/20/Node-js中的Stream模块/">Node.js中的Stream模块</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>注意：</strong></p>
<ol>
<li><p>stream是Node.js提供的又一个仅在服务区端可用的模块，目的是支持“流”这种数据结构。</p>
</li>
<li><p>什么是流？流是一种抽象的数据结构。想象水流，当在水管中流动时，就可以从某个地方（例如自来水厂）源源不断地到达另一个地方（比如你家的洗手池）。我们也可以把数据看成是数据流，比如你敲键盘的时候，就可以把每个字符依次连起来，看成字符流。这个流是从键盘输入到应用程序，实际上它还对应着一个名字：标准输入流（stdin）。</p>
</li>
<li><p>Node.js，Stream 有四种流类型：</p>
<ul>
<li>Readable - 可读操作。</li>
<li>Writable - 可写操作。</li>
<li>Duplex - 可读可写操作.</li>
<li>Transform - 操作被写入数据，然后读出结果。</li>
</ul>
</li>
<li><p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>
<ul>
<li>data - 当有数据可读时触发。</li>
<li>end - 没有更多的数据可读时触发。</li>
<li>error - 在接收和写入过程中发生错误时触发。</li>
<li>finish - 所有数据已被写入到底层系统时触发。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="一-从流中读取数据"><a href="#一-从流中读取数据" class="headerlink" title="一.从流中读取数据"></a>一.从流中读取数据</h3><ol>
<li><p>创建 input.txt 文件，内容如下：</p>
<pre><code>hello world !
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);
var data = &apos;&apos;;

// 创建可读流
var readerStream = fs.createReadStream(&apos;input.txt&apos;);

// 设置编码为 utf8。
readerStream.setEncoding(&apos;UTF8&apos;);

// 处理流事件 --&gt; data, end, and error
readerStream.on(&apos;data&apos;, function(chunk) {
       data += chunk;
   });

readerStream.on(&apos;end&apos;,function(){
       console.log(data);
});

readerStream.on(&apos;error&apos;, function(err){
       console.log(err.stack);
});

    console.log(&quot;程序执行完毕&quot;);
</code></pre></li>
</ol>
<ol>
<li><p>以上代码执行结果如下：</p>
<pre><code>程序执行完毕
hello world !
</code></pre></li>
</ol>
<h3 id="二-写入流"><a href="#二-写入流" class="headerlink" title="二.写入流"></a>二.写入流</h3><ol>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);
var data = &apos;hello world !&apos;;

// 创建一个可以写入的流，写入到文件 output.txt 中
var writerStream = fs.createWriteStream(&apos;output.txt&apos;);

// 使用 utf8 编码写入数据
writerStream.write(data,&apos;UTF8&apos;);

// 标记文件末尾
writerStream.end();

// 处理流事件 --&gt; data, end, and error
writerStream.on(&apos;finish&apos;, function() {
    console.log(&quot;写入完成。&quot;);
});

writerStream.on(&apos;error&apos;, function(err){
       console.log(err.stack);
});

    console.log(&quot;程序执行完毕&quot;);
</code></pre></li>
<li><p>以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：</p>
<pre><code>   $ node main.js 
程序执行完毕
写入完成。
</code></pre></li>
<li><p>查看 output.txt 文件的内容：</p>
<pre><code>$ cat output.txt 
hello world !
</code></pre></li>
</ol>
<h3 id="三-管道流"><a href="#三-管道流" class="headerlink" title="三.管道流"></a>三.管道流</h3><p> 管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。</p>
<p> 以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。</p>
<ol>
<li><p>设置 input.txt 文件内容如下：</p>
<pre><code>Hello! my name is yuxuan.
</code></pre></li>
<li><p>创建 main.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);

// 创建一个可读流
var readerStream = fs.createReadStream(&apos;input.txt&apos;);

// 创建一个可写流
var writerStream = fs.createWriteStream(&apos;output.txt&apos;);

// 管道读写操作
// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中
readerStream.pipe(writerStream);

console.log(&quot;程序执行完毕&quot;);
</code></pre></li>
<li><p>代码执行结果如下：</p>
<pre><code>$ node main.js 
程序执行完毕
</code></pre></li>
<li><p>查看 output.txt 文件的内容：</p>
<pre><code>$ cat output.txt 
Hello! my name is yuxuan.
</code></pre></li>
</ol>
<h3 id="四-链式流"><a href="#四-链式流" class="headerlink" title="四.链式流"></a>四.链式流</h3><ul>
<li>链式是通过连接输出流到另外一个流并创建多个对个流操作链的机制。链式流一般用于管道操作。<br>接下来我们就是用管道和链式来压缩和解压文件。</li>
</ul>
<p><strong>a. 压缩文件</strong></p>
<ol>
<li><p>创建 compress.js 文件, 代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);
var zlib = require(&apos;zlib&apos;);

// 压缩 input.txt 文件为 input.txt.gz
fs.createReadStream(&apos;input.txt&apos;)
.pipe(zlib.createGzip())
.pipe(fs.createWriteStream(&apos;input.txt.gz&apos;));

console.log(&quot;文件压缩完成。&quot;);
</code></pre></li>
<li><p>代码执行结果如下：</p>
<pre><code>$ node compress.js 
文件压缩完成。
</code></pre></li>
<li><p>执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。</p>
</li>
</ol>
<p><strong>b. 解压该文件</strong></p>
<ol>
<li><p>创建 decompress.js 文件，代码如下：</p>
<pre><code>var fs = require(&quot;fs&quot;);
var zlib = require(&apos;zlib&apos;);

    // 解压 input.txt.gz 文件为 input.txt
fs.createReadStream(&apos;input.txt.gz&apos;)
  .pipe(zlib.createGunzip())
  .pipe(fs.createWriteStream(&apos;input.txt&apos;));

console.log(&quot;文件解压完成。&quot;);
</code></pre></li>
<li><p>代码执行结果如下：</p>
<pre><code>$ node decompress.js 
 文件解压完成。
</code></pre></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/">Node.js</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-React注意点" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/10/19/React注意点/" class="article-date">
      <time datetime="2016-10-19T12:10:40.000Z" itemprop="datePublished">2016-10-19</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/19/React注意点/">React注意点</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p><strong>学习React时，碰到一些需要注意的地方。现整理如下：</strong></p>
</blockquote>
<h3 id="一-关于JSX-语法"><a href="#一-关于JSX-语法" class="headerlink" title="一.关于JSX 语法"></a>一.关于JSX 语法</h3><p>React 不是一定要使用 JSX 语法，可以直接使用原生 JS。JSX语法看上去像是在Javascript代码里直接写起了XML标签，实质上这只是一个语法糖，每一个XML标签都会被JSX转换工具转换成纯Javascript代码，所以建议使用 JSX 是因为它能精确定义和反应组件及属性的树状结构，使得组件的结构和组件之间的关系看上去更加清晰。方便MXML和XAML的开发人员 – 因为他们已经使用过类似的语法。</p>
<h3 id="二-HTML-标签-和-React-组件"><a href="#二-HTML-标签-和-React-组件" class="headerlink" title="二.HTML 标签 和 React 组件"></a>二.HTML 标签 和 React 组件</h3><p>在JSX语法中，遇到HTML标签（以&lt;开头）就用HTML规则解析，遇到代码块（以{开头）就用JavaScript规则解析。React 可以渲染 HTML 标签 (strings) 或 React 组件 (classes)。</p>
<p>要渲染 HTML 标签，只需在 JSX 里使用小写字母开头的标签名。</p>
<pre><code>var myDivElement=&lt;div className=&quot;foo&quot;/&gt;;

React.render(myDivElement,document.body);
</code></pre><p>要渲染 React 模块，只需创建一个大写字母开头的本地变量。</p>
<pre><code>var MyComponent = React.createClass({/*...*/});
var myElement = &lt;MyComponent someProperty={true} /&gt;;
React.render(myElement, document.body);
React 的 JSX 里约定分别使用首字母大、小写来区分本地模块的类和 HTML 标签。
</code></pre><h3 id="三-不建议作为-XML-属性名"><a href="#三-不建议作为-XML-属性名" class="headerlink" title="三.不建议作为 XML 属性名"></a>三.不建议作为 XML 属性名</h3><p>由于 JSX 就是 JavaScript，一些标识符像 class 和 for 不建议作为 XML 属性名。作为替代，React DOM 使用 className 和 htmlFor 来做对应的属性。</p>
<h3 id="四-大小写敏感"><a href="#四-大小写敏感" class="headerlink" title="四.大小写敏感"></a>四.大小写敏感</h3><p>上面说了JSX是一个XML语法的预处理器。 XML 语法对大小写敏感，所以习惯了HTML的同学要特别注意这点，否则折腾了半天，都不知道错在哪里。比如：</p>
<pre><code>var Events = React.createClass({
    clickHandler: function(){
        console.log(&apos;You got me!&apos;);
    },
    render: function(){
      return &lt;div onClick={this.clickHandler}&gt;Hello, world!&lt;/div&gt;;
    }
});

React.render( &lt;Events /&gt;,document.body);
</code></pre><p>这里绑定click事件的onClick中C是大写的。</p>
<h3 id="五-React-注释特点"><a href="#五-React-注释特点" class="headerlink" title="五.React 注释特点"></a>五.React 注释特点</h3><ol>
<li>jsx 标签内容注释 <p name="123">hello{// 或 /**/}</p></li>
<li>jsx 标签属性注释 <p name="123" {="" **="" }="">123</p></li>
<li>其实上面提到的大括号的内容都是js 可以参考求值表达式</li>
</ol>
<h3 id="六-React-Css样式与标签嵌套"><a href="#六-React-Css样式与标签嵌套" class="headerlink" title="六.React Css样式与标签嵌套"></a>六.React Css样式与标签嵌套</h3><ol>
<li><p>定义方式与定义对象一样。 css的写法少有变化，属性值需要加引号，属性与属性之间使用逗号分隔，而不在是分号例如</p>
<p>  var style={color:”red”, border:”1px #000 solid”}</p>
</li>
<li><p>样式的引用，React采用style的方式来引用样式；例如</p>
  <div style="{style}"><hellomessage></hellomessage></div>

</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Git常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/10/12/Git常用命令/" class="article-date">
      <time datetime="2016-10-12T11:52:30.000Z" itemprop="datePublished">2016-10-12</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/12/Git常用命令/">Git常用命令</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p><strong>关于Git的常用命令。整理如下</strong>：</p>
</blockquote>
<h3 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1.创建版本库"></a>1.创建版本库</h3><pre><code>$ mkdir learngit
$ cd learngit
$ pwd
/Users/michael/learngit
</code></pre><h3 id="2-通过git-init命令把这个目录变成Git可以管理的仓库，在新建版本库路径下："><a href="#2-通过git-init命令把这个目录变成Git可以管理的仓库，在新建版本库路径下：" class="headerlink" title="2.通过git init命令把这个目录变成Git可以管理的仓库，在新建版本库路径下："></a>2.通过git init命令把这个目录变成Git可以管理的仓库，在新建版本库路径下：</h3><pre><code>$ git init
Initialized empty Git repository in /Users/michael/learngit/.git/
</code></pre><h3 id="3-添加文件到Git仓库，分两步："><a href="#3-添加文件到Git仓库，分两步：" class="headerlink" title="3.添加文件到Git仓库，分两步："></a>3.添加文件到Git仓库，分两步：</h3><p>第一步，用命令git add告诉Git，把文件添加到仓库：</p>
<pre><code>$ git add readme.txt
</code></pre><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<p>第二步，用命令git commit告诉Git，把文件提交到仓库：</p>
<pre><code>$ git commit -m &quot;wrote a readme file&quot;
[master (root-commit) cb926e7] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 100644 readme.txt
</code></pre><h3 id="4-要随时掌握工作区的状态，使用git-status命令。"><a href="#4-要随时掌握工作区的状态，使用git-status命令。" class="headerlink" title="4.要随时掌握工作区的状态，使用git status命令。"></a>4.要随时掌握工作区的状态，使用git status命令。</h3><pre><code>git diff readme.txt
</code></pre><p>如果git status告诉你有文件被修改过，可以用git diff readme.txt查看修改内容。</p>
<h3 id="5-版本回退"><a href="#5-版本回退" class="headerlink" title="5.版本回退"></a>5.版本回退</h3><pre><code>git log  //显示从最近到最远的提交日志，以便确定要回退到哪个版本，每次提交都有一个唯一的id。

git reflog  //用来记录你的每一次命令，以便确定要回到未来的哪个版本。

把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：
$ git reset --hard HEAD^
HEAD is now at ea34578 add distributed
</code></pre><p>返回某个指定id号的那个版本的提交：</p>
<pre><code>$ git reset --hard 3628164
</code></pre><p>查看readme.txt的内容是不是版本add distributed：</p>
<pre><code>$ cat readme.txt
Git is a distributed version control system.
Git is free software.
</code></pre><p>git 允许我们将某个特定的文件回滚到特定的提交，使用的也是 git checkout。</p>
<p>例子：将hello.txt回滚到最初的状态，需要指定回滚到哪个提交，以及文件的全路径。</p>
<pre><code>$ git checkout 09bd8cc1 hello.txt
</code></pre><h3 id="6-撤销修改"><a href="#6-撤销修改" class="headerlink" title="6.撤销修改"></a>6.撤销修改</h3><pre><code>git checkout -- file  //丢弃工作区的修改：

$ git checkout -- readme.txt
命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：
一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
总之，就是让这个文件回到最近一次git commit或git add时的状态。

git add到暂存区了，git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区，
git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。
</code></pre><h3 id="7-删除文件"><a href="#7-删除文件" class="headerlink" title="7.删除文件"></a>7.删除文件</h3><p>一种是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</p>
<pre><code>$ git rm test.txt
rm &apos;test.txt&apos;

$ git commit -m &quot;remove test.txt&quot;
[master d17efd8] remove test.txt
1 file changed, 1 deletion(-)

$ delete mode 100644 test.txt
现在，文件就从版本库中被删除了。
</code></pre><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<pre><code>$ git checkout -- test.txt

git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。
</code></pre><h3 id="8-远程仓库"><a href="#8-远程仓库" class="headerlink" title="8.远程仓库"></a>8.远程仓库</h3><h4 id="第一种：添加远程库："><a href="#第一种：添加远程库：" class="headerlink" title="第一种：添加远程库："></a>第一种：添加远程库：</h4><pre><code>1.mkdir learngit

2.cd learngit

3.git init

4.添加文件

5.git add .

6.git commit -m &quot;test&quot;

7.在github上创建仓库，复制地址

8. git remote add origin git@github.com:michaelliao/learngit.git

9.git push -u origin master
</code></pre><p><strong>注意：</strong></p>
<p>  若出错：fatal: refusing to merge unrelated histories</p>
<p>  解决：git pull origin master –allow-unrelated-histories</p>
<p>  //github仓库中存在本地项目中不存在的文件，发生了冲图，所以应该先将github上的仓库全部pull下来，让两个仓库相关联。</p>
<p>  最后依次用命令：</p>
<pre><code>git add .              
git commit -m &quot;commit2&quot;                    
git push origin master:master
</code></pre><h4 id="第二种：从远程克隆仓库"><a href="#第二种：从远程克隆仓库" class="headerlink" title="第二种：从远程克隆仓库"></a>第二种：从远程克隆仓库</h4><pre><code>1.创建仓库，复制地址

2.克隆：git clone  git@github.com:michaelliao/learngit.git

3.添加文件

4.git add .

5.git commit -m &quot;test&quot;

6.git push -u origin master
</code></pre><h3 id="9-分支管理"><a href="#9-分支管理" class="headerlink" title="9.分支管理"></a>9.分支管理</h3><h4 id="a-创建与合并分支："><a href="#a-创建与合并分支：" class="headerlink" title="a.创建与合并分支："></a>a.创建与合并分支：</h4><pre><code>1.创建分支：git branch dev

2.切换到分支：git checkout dev

创建+切换分支：git checkout -b dev

3.查看当前分支：gir branch 

4.将指定分支合并到当前分支,假如当前分支为:master：git merge dev

5.删除dev分支：git branch -d dev

强行删除，需要使用命令:git branch -D dev。
</code></pre><h4 id="b-解决冲突："><a href="#b-解决冲突：" class="headerlink" title="b.解决冲突："></a>b.解决冲突：</h4><ol>
<li><p>用带参数的git log可以看到分支的合并情况：git log –graph –pretty=oneline –abbrev-commit<br>c.bug分支：修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；<br>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p>
</li>
<li><p>把当前工作现场“储藏”起来：git stash。现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
</li>
<li><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：<br>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了。工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看。</p>
</li>
</ol>
<h4 id="c-多人协作："><a href="#c-多人协作：" class="headerlink" title="c.多人协作："></a>c.多人协作：</h4><pre><code>1.查看远程库的详细信息：git remote -v

2.推送分支：git push origin master

3.抓取分支：
</code></pre><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p>
<p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>
<h3 id="10-标签管理："><a href="#10-标签管理：" class="headerlink" title="10.标签管理："></a>10.标签管理：</h3><h4 id="a-创建标签："><a href="#a-创建标签：" class="headerlink" title="a.创建标签："></a>a.创建标签：</h4><p>  首先，切换到需要打标签的分支上：git checkout branch-name然后打标签：git tag tag-name。git tag查看所有标签。</p>
<p>  如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>  方法是找到历史提交的commit id，然后打上就可以了： </p>
<pre><code>$git log --pretty=oneline --abbrev-commit

6a5819e merged bug fix 101
cc17032 fix bug 1017825a50 merge with no-ff
6224937 add merge
59bc1cb conflict fixed
400b400 &amp; simple
75a857c AND simple
fec145a branch test
d17efd8 remove test.txt
...
</code></pre><p>比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令：</p>
<pre><code>$ git tag v0.9 6224937

再用命令git tag查看标签.
git show &lt;tagname&gt;查看标签信息

创建带有说明的标签，用-a指定标签名，-m指定说明文字：
$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164

通过-s用私钥签名一个标签：
$ git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a
</code></pre><h3 id="11-操作标签："><a href="#11-操作标签：" class="headerlink" title="11.操作标签："></a>11.操作标签：</h3><pre><code>命令git push origin &lt;tagname&gt;可以推送一个本地标签；

命令git push origin --tags可以推送全部未推送过的本地标签；

命令git tag -d &lt;tagname&gt;可以删除一个本地标签；

命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。
</code></pre><h3 id="12-配置别名："><a href="#12-配置别名：" class="headerlink" title="12.配置别名："></a>12.配置别名：</h3><pre><code>$ git config --global alias.st status  //用st表示status

然后用git st就可以查看状态。 
</code></pre><h3 id="13-忽略文件："><a href="#13-忽略文件：" class="headerlink" title="13.忽略文件："></a>13.忽略文件：</h3><p>大部分项目中，有些文件，文件夹是我们不想提交的。为了防止一不小心提交，我们需要gitignore文件：</p>
<p>在项目根目录创建.gitignore文件，在文件中列出不需要提交的文件名，文件夹名，每个一行，.gitignore文件需要提交，就像普通文件一样。</p>
<p>通常会被ignore的文件有：</p>
<ol>
<li>log文件</li>
<li>task runner builds</li>
<li>node_modules等文件夹</li>
<li>IDEs生成的文件</li>
<li>个人笔记</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-CSS3中box-sizing属性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/18/CSS3中box-sizing属性/" class="article-date">
      <time datetime="2016-09-18T12:36:11.000Z" itemprop="datePublished">2016-09-18</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/18/CSS3中box-sizing属性/">CSS3中box-sizing属性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>简介：</strong></p>
<p>box-sizing 属性允许您以特定的方式定义匹配某个区域的特定元素。</p>
<p><strong>语法：</strong></p>
<p>box-sizing：content-box | border-box 默认值：content-box</p>
<p><strong>取值：</strong></p>
<ol>
<li><p>content-box，padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding )。此属性表现为标准模式下的盒模型。</p>
</li>
<li><p>border-box，padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width )。此属性表现为怪异模式下的盒模型。</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<ol>
<li><p>content-box:</p>
<p> .test1{ box-sizing:content-box; width:200px; padding:10px; border:15px solid #eee; }</p>
</li>
</ol>
<blockquote>
<p>实际宽度为：200+（10+10）+（15+15）， 内容宽度为：200 </p>
</blockquote>
<ol>
<li><p>border-box:</p>
<p> .test2{ box-sizing:border-box; width:200px; padding:10px; border:15px solid #eee; }</p>
</li>
</ol>
<blockquote>
<p>实际宽度为：200， 内容宽度为：200-（10+10）-（15+15）</p>
</blockquote>
<p><strong>内核类型写法：</strong></p>
<pre><code>Webkit(Chrome/Safari)-webkit-box-sizing

Gecko(Firefox)-moz-box-sizing

Presto(Opera)-o-box-sizing

Trident(IE)IE8:-ms-box-sizing/IE9:box-sizing
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS3/">CSS3</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-CSS3新增的属性" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/17/CSS3新增的属性/" class="article-date">
      <time datetime="2016-09-17T11:57:02.000Z" itemprop="datePublished">2016-09-17</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/17/CSS3新增的属性/">CSS3新增的属性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>注意：</strong></p>
<blockquote>
<p>由于CSS5标准还未完全订下来，所以各种内核的浏览器都有自己的标准，为了不使属性混淆，所以各家在各自标准前加了一个前缀，</p>
<p>如：</p>
<p> -moz-  主要是firefox火狐</p>
<p> -webikt-  主要是chrome谷歌</p>
<p> -o-  主要是用于苹果机上的浏览器</p>
</blockquote>
<h2 id="一-box-shadow-阴影效果"><a href="#一-box-shadow-阴影效果" class="headerlink" title="一. box-shadow(阴影效果)"></a>一. box-shadow(阴影效果)</h2><p><strong>使用:</strong></p>
<pre><code>box-shadow: 20px 10px 0 #000;
-moz-box-shadow: 20px 10px 0 #000;
-webkit-box-shadow: 20px 10px 0 #000;
</code></pre><p><strong>支持:</strong></p>
<blockquote>
<p>FF3.5, Safari 4, Chrome 3</p>
</blockquote>
<h2 id="二-border-colors-为边框设置多种颜色"><a href="#二-border-colors-为边框设置多种颜色" class="headerlink" title="二. border-colors(为边框设置多种颜色)"></a>二. border-colors(为边框设置多种颜色)</h2><p><strong>使用:</strong></p>
<pre><code>border: 10px solid #000;
-moz-border-bottom-colors: #555 #666 #777 #888 #999 #aaa #bbb #ccc;
-moz-border-top-colors: #555 #666 #777 #888 #999 #aaa #bbb #ccc;
-moz-border-left-colors: #555 #666 #777 #888 #999 #aaa #bbb #ccc;
-moz-border-right-colors: #555 #666 #777 #888 #999 #aaa #bbb #ccc;
</code></pre><p><strong>说明:</strong></p>
<blockquote>
<p>颜色值数量不固定, 且FF的私有写法不支持缩写: -moz-border-colors: #333 #444 #555;</p>
</blockquote>
<p><strong>支持:</strong></p>
<blockquote>
<p>FF3+</p>
</blockquote>
<h2 id="三-boder-image-图片边框"><a href="#三-boder-image-图片边框" class="headerlink" title="三. boder-image(图片边框)"></a>三. boder-image(图片边框)</h2><p><strong>使用:</strong></p>
<pre><code>-moz-border-image: url(exam.png) 20 20 20 20 repeat;
-webkit-border-image: url(exam.png) 20 20 20 20 repeat;
</code></pre><p><strong>说明:</strong></p>
<blockquote>
<p>(1). 20 20 20 20 —边框的宽度, 分别对应top, right, bottom, left边框, 改变宽度可以实现不同的效果;<br>(2). 边框图片效果(目前仅实现了两种):<br>   repeat — 边框图片会平铺, 类似于背景重复;<br>   stretch — 边框图片会以拉伸的方式来铺满整个边框;<br>(3). 必须将元素的边框厚度设置为非0非auto值.</p>
</blockquote>
<p><strong>支持:</strong></p>
<blockquote>
<p>FF 3.5, Safari 4, Chrome 3</p>
</blockquote>
<h2 id="四-text-shadow-文本阴影"><a href="#四-text-shadow-文本阴影" class="headerlink" title="四. text-shadow(文本阴影)"></a>四. text-shadow(文本阴影)</h2><p><strong>使用:</strong></p>
<pre><code>text-shadow: [&lt;颜色&gt;&lt;水平偏移&gt;&lt;纵向偏移&gt;&lt;模糊半径&gt;] || [&lt;水平偏移&gt;&lt;纵向偏移&gt;&lt;模糊半径&gt;&lt;颜色&gt;];
</code></pre><p><strong>说明:</strong></p>
<blockquote>
<p>(1) &lt;颜色&gt;和&lt;模糊半径&gt;是可选的, 当&lt;颜色&gt;未指定时, 将使用文本颜色; 当&lt;模糊半径&gt;未指定时, 半径值为0;<br>(2) shadow可以是逗号分隔的列表, 如:<br>   text-shadow: 2px 2px 2px #ccc, 3px 3px 3px #ddd;<br>(3) 阴影效果会按照shadow list中指定的顺序应用到元素上;<br>(4) 这些阴影效果有可能相互重叠, 但不会叠加文本本身;<br>(5) 阴影可能会跑到容器的边界之外, 但不会影响容器的大小.</p>
</blockquote>
<p><strong>支持:</strong></p>
<blockquote>
<p>FF 3.5, Opera 10, Safari 4, Chrome 3</p>
</blockquote>
<h2 id="五-text-overflow-文本截断"><a href="#五-text-overflow-文本截断" class="headerlink" title="五. text-overflow(文本截断)"></a>五. text-overflow(文本截断)</h2><p><strong>使用:</strong></p>
<pre><code>text-overflow: inherit | ellipsis | clip ;
-o-text-overflow: inherit | ellipsis | clip;
</code></pre><p><strong>说明:</strong></p>
<blockquote>
<p>(1) 还有一个属性ellipsis-word, 但各浏览器均不支持.</p>
</blockquote>
<p><strong>支持:</strong> </p>
<blockquote>
<p> IE6+, Safari4, Chrome3, Opera10</p>
</blockquote>
<h2 id="六-word-wrap-自动换行"><a href="#六-word-wrap-自动换行" class="headerlink" title="六. word-wrap(自动换行)"></a>六. word-wrap(自动换行)</h2><p><strong>使用:</strong></p>
<pre><code>word-wrap: normal | break-word;
</code></pre><p><strong>支持:</strong>    </p>
<blockquote>
<p>IE6+, FF 3.5, Safari 4, Chrome 3</p>
<h2 id="七-border-radius-圆角边框"><a href="#七-border-radius-圆角边框" class="headerlink" title="七. border-radius(圆角边框)"></a>七. border-radius(圆角边框)</h2><p><strong>使用:</strong></p>
</blockquote>
<pre><code>-moz-border-radius: 5px;
-webkit-border-radius: 5px;
</code></pre><p><strong>支持:</strong></p>
<blockquote>
<p>FF 3+, Safari 4, Chrome 3</p>
</blockquote>
<h2 id="八-opacity-不透明度"><a href="#八-opacity-不透明度" class="headerlink" title="八.  opacity(不透明度)"></a>八.  opacity(不透明度)</h2><p><strong>使用:</strong></p>
<pre><code>opacity: 0.5;
filter: alpha(opacity=50); /* for IE6, 7 */
-ms-filter(opacity=50); /* for IE8 */
</code></pre><p><strong>支持:</strong></p>
<blockquote>
<p>all</p>
</blockquote>
<h2 id="九-box-sizing-控制盒模型的组成模式"><a href="#九-box-sizing-控制盒模型的组成模式" class="headerlink" title="九. box-sizing(控制盒模型的组成模式)"></a>九. box-sizing(控制盒模型的组成模式)</h2><p><strong>使用:</strong></p>
<pre><code>box-sizing: content-box | border-box; // for opera
-moz-box-sizing: content-box | border-box;
-webkit-box-sizing: content-box | border-box;
</code></pre><p><strong>说明:</strong></p>
<blockquote>
<ol>
<li>content-box:<br>使用此值时, 盒模型的组成模式是, 元素宽度 = content + padding + border;</li>
<li>border-box:<br>使用此值时, 盒模型的组成模式是, 元素宽度 = content(即使设置了padding和border, 元素的宽度<br>也不会变)。</li>
</ol>
</blockquote>
<p><strong>支持:</strong></p>
<blockquote>
<p>FF3+, Opera 10, Safari 4, Chrome 3</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS3/">CSS3</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-JavaScript中的String对象" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/16/JavaScript中的String对象/" class="article-date">
      <time datetime="2016-09-16T14:23:56.000Z" itemprop="datePublished">2016-09-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/16/JavaScript中的String对象/">JavaScript中的String对象</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="String的描述"><a href="#String的描述" class="headerlink" title="String的描述"></a>String的描述</h2><pre><code>字符串是JavaScript中的一种基本的数据类型。
String 对象的length属性声明了该字符串中的字符数。
String 类定义了大量操作字符串的方法，例如从字符串中提取字符或子串，或者检索字符或子串。
String 对象用于处理文本（字符串）。
</code></pre><p><strong>创建 String 对象的语法：</strong></p>
<pre><code>new String(s);
String(s);
</code></pre><p><strong>参数</strong></p>
<pre><code>参数 s 是要存储在 String 对象中或转换成原始字符串的值。
</code></pre><p><strong>返回值</strong></p>
<pre><code>当 String() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 String 对象，存放的是字符串 s 或 s 的字符串表示。
当不用 new 运算符调用 String() 时，它只把 s 转换成原始的字符串，并返回转换后的值。
</code></pre><h2 id="JavaScript-中-slice-、substr-和-substring的区别："><a href="#JavaScript-中-slice-、substr-和-substring的区别：" class="headerlink" title="JavaScript 中 slice 、substr 和 substring的区别："></a>JavaScript 中 slice 、substr 和 substring的区别：</h2><ol>
<li><p>String.slice(start,end): 一个新的字符串。包括字符串 stringObject 从 start 开始（包括 start）到 end 结束（不包括 end）为止的所有字符.</p>
</li>
<li><p>String.substring(start,end) 这个就有点特别了，它是先从start，end里找出一个较小的值. 然后从字符串的开始位置算起，截取较小值位置和较大值位置之间的字符串,截取出来的字符串的长度为较大值与较小值之间的差。<br>一个新的字符串，该字符串值包含 stringObject 的一个子字符串，其内容是从 start 处到 stop-1 处的所有字符，其长度为 stop 减 start。</p>
</li>
<li><p>String.substr(start,end) 这个就是我们常用的从指定的位置(start)截取指定长度(end)的字符串。<br>一个新的字符串，包含从 stringObject 的 start（包括 start 所指的字符） 处开始的 lenght 个字符。如果没有指定 lenght，那么返回的字符串包含从 start<br>到 stringObject 的结尾的字符。<br>String 对象的方法 slice()、substring() 和 substr() (不建议使用)都可返回字符串的指定部分。slice() 比 substring() 要灵活一些，因为它允许使用负数作为参数。slice() 与 substr() 有所不同，因为它用两个字符的位置来指定子串，而 substr() 则用字符位置和长度来指定子串。</p>
</li>
</ol>
<h2 id="String对象中常用的方法："><a href="#String对象中常用的方法：" class="headerlink" title="String对象中常用的方法："></a>String对象中常用的方法：</h2><h4 id="1-charCodeAt方法返回一个整数，代表指定位置字符的Unicode编码。"><a href="#1-charCodeAt方法返回一个整数，代表指定位置字符的Unicode编码。" class="headerlink" title="1. charCodeAt方法返回一个整数，代表指定位置字符的Unicode编码。"></a>1. charCodeAt方法返回一个整数，代表指定位置字符的Unicode编码。</h4><p>用法：</p>
<pre><code>strObj.charCodeAt(index)
</code></pre><p>说明：</p>
<pre><code>index将被处理字符的从零开始计数的编号。有效值为0到字符串长度减1的数字。
如果指定位置没有字符，将返回NaN。
</code></pre><p>例如：</p>
<pre><code>var str = &quot;ABC&quot;;
str.charCodeAt(0);
结果：65
</code></pre><h4 id="2-fromCharCode方法从一些Unicode字符串中返回一个字符串。"><a href="#2-fromCharCode方法从一些Unicode字符串中返回一个字符串。" class="headerlink" title="2. fromCharCode方法从一些Unicode字符串中返回一个字符串。"></a>2. fromCharCode方法从一些Unicode字符串中返回一个字符串。</h4><p>用法：</p>
<pre><code>String.fromCharCode([code1[,code2...]])
</code></pre><p>说明：</p>
<pre><code>code1，code2...是要转换为字符串的Unicode字符串序列。如果没有参数，结果为空字符串。
</code></pre><p>例如：</p>
<pre><code>String.fromCharCode(65,66,112);
结果：ABp
</code></pre><h4 id="3-charAt方法返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串。"><a href="#3-charAt方法返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串。" class="headerlink" title="3. charAt方法返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串。"></a>3. charAt方法返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串。</h4><p>用法：</p>
<pre><code>strObj.charAt(index)
</code></pre><p>说明：</p>
<pre><code>index想得到的字符的基于零的索引。有效值是0与字符串长度减一之间的值。
</code></pre><p>例如：</p>
<pre><code>var str = &quot;ABC&quot;;
str.charAt(1);
结果：B
</code></pre><h4 id="4-slice方法返回字符串的片段。"><a href="#4-slice方法返回字符串的片段。" class="headerlink" title="4. slice方法返回字符串的片段。"></a>4. slice方法返回字符串的片段。</h4><p>用法：</p>
<pre><code>strObj.slice(start[,end])
</code></pre><p>说明：</p>
<pre><code>start下标从0开始的strObj指定部分其实索引。如果start为负，将它作为length+start处理，此处length为字符串的长度。
end小标从0开始的strObj指定部分结束索引。如果end为负，将它作为length+end处理，此处length为字符串的长度。
</code></pre><p>例如：</p>
<pre><code>var str = &quot;ABCDEF&quot;;
str.slice(2,4);
结果：CD
</code></pre><h4 id="5-substring方法返回位于String对象中指定位置的子字符串。"><a href="#5-substring方法返回位于String对象中指定位置的子字符串。" class="headerlink" title="5. substring方法返回位于String对象中指定位置的子字符串。"></a>5. substring方法返回位于String对象中指定位置的子字符串。</h4><p>用法：</p>
<pre><code>strObj.substring(start,end)
</code></pre><p>说明：</p>
<pre><code>start指明子字符串的起始位置，该索引从0开始起算。
end指明子字符串的结束位置，该索引从0开始起算。
substring方法使用start和end两者中的较小值作为子字符串的起始点。如果start或end为NaN或者为负数，那么将其替换为0。
</code></pre><p>例如：</p>
<pre><code>var str = &quot;ABCDEF&quot;;
str.substring(2,4); // 或 str.substring(4,2);
结果：CD
</code></pre><h4 id="6-substr方法返回一个从指定位置开始的指定长度的子字符串。"><a href="#6-substr方法返回一个从指定位置开始的指定长度的子字符串。" class="headerlink" title="6. substr方法返回一个从指定位置开始的指定长度的子字符串。"></a>6. substr方法返回一个从指定位置开始的指定长度的子字符串。</h4><p>用法：</p>
<pre><code>strObj.substr(start[,length])
</code></pre><p>说明：</p>
<pre><code>start所需的子字符串的起始位置。字符串中的第一个字符的索引为0。
length在返回的子字符串中应包括的字符个数。
</code></pre><p>例如：</p>
<pre><code>var str = &quot;ABCDEF&quot;;
str.substr(2,4);
结果：CDEF
</code></pre><h4 id="7-indexOf方法返回String对象内第一次出现子字符串位置。如果没有找到子字符串，则返回-1。"><a href="#7-indexOf方法返回String对象内第一次出现子字符串位置。如果没有找到子字符串，则返回-1。" class="headerlink" title="7. indexOf方法返回String对象内第一次出现子字符串位置。如果没有找到子字符串，则返回-1。"></a>7. indexOf方法返回String对象内第一次出现子字符串位置。如果没有找到子字符串，则返回-1。</h4><p>用法：</p>
<pre><code>strObj.indexOf(substr[,startIndex])
</code></pre><p>说明：</p>
<pre><code>substr要在String对象中查找的子字符串。
startIndex该整数值指出在String对象内开始查找的索引。如果省略，则从字符串的开始处查找。
</code></pre><p>例如：</p>
<pre><code>var str = &quot;ABCDECDF&quot;;
str.indexOf(&quot;CD&quot;，1); // 由1位置从左向右查找 123...
结果：2
</code></pre><h4 id="8-lastIndexOf方法返回String对象中字符串最后出现的位置。如果没有匹配到子字符串，则返回-1。"><a href="#8-lastIndexOf方法返回String对象中字符串最后出现的位置。如果没有匹配到子字符串，则返回-1。" class="headerlink" title="8. lastIndexOf方法返回String对象中字符串最后出现的位置。如果没有匹配到子字符串，则返回-1。"></a>8. lastIndexOf方法返回String对象中字符串最后出现的位置。如果没有匹配到子字符串，则返回-1。</h4><p>用法：</p>
<pre><code>strObj.lastIndexOf(substr[,startindex])
</code></pre><p>说明：</p>
<pre><code>substr要在String对象内查找的子字符串。
startindex该整数值指出在String对象内进行查找的开始索引位置。如果省略，则查找从字符串的末尾开始。
</code></pre><p>例如：</p>
<pre><code>var str = &quot;ABCDECDF&quot;;
str.lastIndexOf(&quot;CD&quot;,6); // 由6位置从右向左查找 ...456
结果：5
</code></pre><h4 id="9-search方法返回与正则表达式查找内容匹配的第一个字符串的位置。"><a href="#9-search方法返回与正则表达式查找内容匹配的第一个字符串的位置。" class="headerlink" title="9. search方法返回与正则表达式查找内容匹配的第一个字符串的位置。"></a>9. search方法返回与正则表达式查找内容匹配的第一个字符串的位置。</h4><p>用法：</p>
<pre><code>strObj.search(reExp)
</code></pre><p>说明：</p>
<pre><code>reExp包含正则表达式模式和可用标志的正则表达式对象。
</code></pre><p>例如：</p>
<pre><code>var str = &quot;ABCDECDF&quot;;
str.search(&quot;CD&quot;); // 或 str.search(/CD/i);
结果：2
</code></pre><h4 id="10-concat方法返回字符串值，该值包含了两个或多个提供的字符串的连接。"><a href="#10-concat方法返回字符串值，该值包含了两个或多个提供的字符串的连接。" class="headerlink" title="10. concat方法返回字符串值，该值包含了两个或多个提供的字符串的连接。"></a>10. concat方法返回字符串值，该值包含了两个或多个提供的字符串的连接。</h4><p>用法：</p>
<pre><code>str.concat([string1[,string2...]])
</code></pre><p>说明：</p>
<pre><code>string1，string2要和所有其他指定的字符串进行连接的String对象或文字。
</code></pre><p>例如：</p>
<pre><code>var str = &quot;ABCDEF&quot;;
str.concat(&quot;ABCDEF&quot;,&quot;ABC&quot;);
结果：ABCDEFABCDEFABC
</code></pre><h4 id="11-将一个字符串分割为子字符串，然后将结果作为字符串数组返回。"><a href="#11-将一个字符串分割为子字符串，然后将结果作为字符串数组返回。" class="headerlink" title="11. 将一个字符串分割为子字符串，然后将结果作为字符串数组返回。"></a>11. 将一个字符串分割为子字符串，然后将结果作为字符串数组返回。</h4><p>用法：</p>
<pre><code>strObj.split([separator[,limit]])
</code></pre><p>说明：</p>
<pre><code>separator字符串或 正则表达式 对象，它标识了分隔字符串时使用的是一个还是多个字符。如果忽略该选项，返回包含整个字符串的单一元素数组。
limit该值用来限制返回数组中的元素个数。
</code></pre><p>例如：</p>
<pre><code>var str = &quot;AA BB CC DD EE FF&quot;;
alert(str.split(&quot; &quot;，3));
结果：AA,BB,CC
</code></pre><h4 id="12-toLowerCase方法返回一个字符串，该字符串中的字母被转换成小写。"><a href="#12-toLowerCase方法返回一个字符串，该字符串中的字母被转换成小写。" class="headerlink" title="12. toLowerCase方法返回一个字符串，该字符串中的字母被转换成小写。"></a>12. toLowerCase方法返回一个字符串，该字符串中的字母被转换成小写。</h4><p>例如：</p>
<pre><code>var str = &quot;ABCabc&quot;;
str.toLowerCase();
结果：abcabc
</code></pre><h4 id="13-toUpperCase方法返回一个字符串，该字符串中的所有字母都被转换为大写字母。"><a href="#13-toUpperCase方法返回一个字符串，该字符串中的所有字母都被转换为大写字母。" class="headerlink" title="13. toUpperCase方法返回一个字符串，该字符串中的所有字母都被转换为大写字母。"></a>13. toUpperCase方法返回一个字符串，该字符串中的所有字母都被转换为大写字母。</h4><p>例如：</p>
<pre><code>var str = &quot;ABCabc&quot;;
str.toUpperCase();
结果：ABCABC
</code></pre><blockquote>
<p>虽然js String对象已经提供像slice、replace、indexOf和substring等方法,但在实际项目应用中会对其进行扩展，以达到实用、方便目的。注释很详细，废话少说，代码如下：</p>
</blockquote>
<h2 id="String对象方法扩展："><a href="#String对象方法扩展：" class="headerlink" title="String对象方法扩展："></a>String对象方法扩展：</h2><blockquote>
<p>字符串-格式化</p>
</blockquote>
<pre><code>String.prototype.format = function(){
var args = arguments;//获取函数传递参数数组,以便在replace回调函数内使用
var regex = /\{(\d+)\}/g;//匹配并捕获所有 形如:{数字} 字串
return this.replace(regex,function(m,i){//参数=匹配子串+第几次匹配+匹配字串位置+源字符串
return args[i];
});
}
</code></pre><blockquote>
<p>字符串-去掉前后空白字符</p>
</blockquote>
<pre><code>String.prototype.trim = function(){
return this.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
}
</code></pre><blockquote>
<p>字符串-去掉前空白字符</p>
</blockquote>
<pre><code>String.prototype.ltrim = function(){
return this.replace(/(^\s*)/g, &quot;&quot;);
}
</code></pre><blockquote>
<p>字符串-去掉后空白字符</p>
</blockquote>
<pre><code>String.prototype.rtrim = function(){
return this.replace(/(\s*$)/g, &quot;&quot;);
}
</code></pre><blockquote>
<p>字符串-获取以ASCII编码字节数 英文占1字节 中文占2字节</p>
</blockquote>
<pre><code>String.prototype.lenASCII=function(){
return this.replace(/[^\x00-\xff]/g,&apos;xx&apos;).length;//将所有非\x00-\xff字符换为xx两个字符,再计算字符串
}
</code></pre><blockquote>
<p>字符串-获取以UNICODE编码字节数 一个字符均占2个字节</p>
</blockquote>
<pre><code>String.prototype.lenUNICODE=function(){
return this.length*2;
}
ps：若对js提供类型对象或自定义对象进行方法扩展，应利用原型prototype这个对象属性进行扩展，具体方式以下:

String.prototype.trim=function(){
//...代码略
};
String.prototype.ltrim=function(){
//...代码略
};
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-JavaScript中的Array数组" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/16/JavaScript中的Array数组/" class="article-date">
      <time datetime="2016-09-16T14:14:29.000Z" itemprop="datePublished">2016-09-16</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/16/JavaScript中的Array数组/">JavaScript中的Array数组</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li><p>介绍：介绍 Array 数组对象的说明、定义方式以及属性。</p>
</li>
<li><p>实例方法：介绍 Array 对象的实例方法：concat、every、filter、forEach、indexOf、join、lastIndexOf、map、pop、push、reverse、shift、slice、sort、splice、toString、tounshift等。</p>
</li>
<li><p>静态方法：介绍 Array 对象的静态方法：Array.isArray()。</p>
</li>
<li><p>实际操作：对 Array 进行示例操作：索引、for遍历、浅度复制、深度复制等操作。</p>
</li>
</ol>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h3 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h3><pre><code>数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript数组是无类型：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。 --《JavaScript权威指南(第六版)》
</code></pre><h3 id="1-2-定义方式"><a href="#1-2-定义方式" class="headerlink" title="1.2 定义方式"></a>1.2 定义方式</h3><p>var names = new Array(“张三”, “李四”, “王五”);<br>//或者<br>var names = [“张三”, “李四”, “王五”];</p>
<h3 id="1-3-属性"><a href="#1-3-属性" class="headerlink" title="1.3 属性"></a>1.3 属性</h3><p>length：表示数组内的元素长度。</p>
<h2 id="2-实例方法"><a href="#2-实例方法" class="headerlink" title="2. 实例方法"></a>2. 实例方法</h2><p>常用方法：</p>
<pre><code>1) unshift() ：在数组头部插入元素

2) shift() ：移除并返回数组的第一个元素

3) push() ：在数组尾部插入元素

4) pop() ：移除并返回数组的最后一个元素
</code></pre><h3 id="2-1-concat-：把元素衔接到数组中。不会修改原先的array-返回新的数组"><a href="#2-1-concat-：把元素衔接到数组中。不会修改原先的array-返回新的数组" class="headerlink" title="2.1 concat() ：把元素衔接到数组中。不会修改原先的array,返回新的数组"></a>2.1 concat() ：把元素衔接到数组中。不会修改原先的array,返回新的数组</h3><p>参数：</p>
<pre><code>①value1,value2.....valueN ：任意多个值
</code></pre><p>返回值：</p>
<pre><code>{Array} 一个新的数组，包含原先的Array和新加入的元素。
</code></pre><p>示例：</p>
<pre><code>var demoArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
var demoArray2 = demoArray.concat(&apos;e&apos;);
console.log(demoArray); // =&gt; demoArray:[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]  原数组不发生变更
console.log(demoArray2); // =&gt; [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;e&apos;]
</code></pre><h3 id="2-2-every-：依次遍历元素，判断每个元素是否都为true"><a href="#2-2-every-：依次遍历元素，判断每个元素是否都为true" class="headerlink" title="2.2 every() ：依次遍历元素，判断每个元素是否都为true"></a>2.2 every() ：依次遍历元素，判断每个元素是否都为true</h3><p>参数：</p>
<pre><code>function(value,index,self){} ：每个元素都会使用此函数判断是否为true，当判断到一个为false时，立即结束遍历。

value ：数组遍历的元素

index ：元素序号

self ：Array本身
</code></pre><p>返回值：</p>
<pre><code>{Boolean} ：只有每个元素都为true才返回true；只要一个为false，就返回false。
</code></pre><p>示例：</p>
<pre><code>var demoArray = [1, 2, 3];
var rs = demoArray.every(function (value, index, self) {
return value &gt; 0;
});
console.log(rs); // =&gt; true
</code></pre><h3 id="2-3-filter-：依次遍历元素，返回包含符合条件元素的新的数组"><a href="#2-3-filter-：依次遍历元素，返回包含符合条件元素的新的数组" class="headerlink" title="2.3 filter() ：依次遍历元素，返回包含符合条件元素的新的数组"></a>2.3 filter() ：依次遍历元素，返回包含符合条件元素的新的数组</h3><p>参数：</p>
<pre><code>function(value,index,self){} ：每个元素依次调用此函数，返回包含符合条件元素的新的数组。

value ：数组遍历的元素

index ：元素序号

self ：Array本身
</code></pre><p>返回值：</p>
<pre><code>{Array} 一个包含符合条件元素的新的数组
</code></pre><p>示例：</p>
<pre><code>var demoArray = [1, 2, 3];
var rs = demoArray.filter(function (value, index, self) {
return value &gt; 0;
});
console.log(rs); // =&gt; [1, 2, 3]
</code></pre><h3 id="2-4-forEach-：依次遍历元素，执行指定的函数；无返回值"><a href="#2-4-forEach-：依次遍历元素，执行指定的函数；无返回值" class="headerlink" title="2.4 forEach() ：依次遍历元素，执行指定的函数；无返回值"></a>2.4 forEach() ：依次遍历元素，执行指定的函数；无返回值</h3><p>参数：</p>
<pre><code>function(value,index,self){} ：每个元素依次调用此函数

value ：数组遍历的元素

index ：元素序号

self ：Array本身
</code></pre><p>返回值：无</p>
<p>示例：</p>
<pre><code>var demoArray = [1, 2, 3];
demoArray.forEach(function (value, index, self) {
console.log(value); // =&gt; 依次输出：1  2  3
});
</code></pre><h3 id="2-5-indexOf-：在数组中查找匹配元素。若不存在匹配的元素时，就返回-1。查找的时候使用”-”运算符，所以要区分1和’1’"><a href="#2-5-indexOf-：在数组中查找匹配元素。若不存在匹配的元素时，就返回-1。查找的时候使用”-”运算符，所以要区分1和’1’" class="headerlink" title="2.5 indexOf() ：在数组中查找匹配元素。若不存在匹配的元素时，就返回-1。查找的时候使用”===”运算符，所以要区分1和’1’"></a>2.5 indexOf() ：在数组中查找匹配元素。若不存在匹配的元素时，就返回-1。查找的时候使用”===”运算符，所以要区分1和’1’</h3><p>参数：</p>
<pre><code>①value ：要在数组中查找的值。

②start ：开始查找的序号位置，如果省略，则为0.
</code></pre><p>返回值：</p>
<pre><code>{Int} ：返回数组中第一个匹配value的序号，若不存在，返回-1
</code></pre><p>示例：</p>
<pre><code>[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].indexOf(&apos;a&apos;); // =&gt;0
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].indexOf(&apos;a&apos;, 1); // =&gt;-1
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].indexOf(&apos;d&apos;); // =&gt;-1
[1, 2, 3].indexOf(&apos;1&apos;); // =&gt; -1 ：采用的&apos;===&apos;匹配方式
</code></pre><h3 id="2-6-join-：将数组中所有元素通过一个分隔符拼接为一个字符串"><a href="#2-6-join-：将数组中所有元素通过一个分隔符拼接为一个字符串" class="headerlink" title="2.6 join() ：将数组中所有元素通过一个分隔符拼接为一个字符串"></a>2.6 join() ：将数组中所有元素通过一个分隔符拼接为一个字符串</h3><p>参数：</p>
<pre><code>①sparator {String}：各元素之间的分隔符，如果省略，默认以因为英文逗号&apos;,&apos;分隔。
</code></pre><p>返回值：</p>
<pre><code>{String} ：各元素以sparator为分隔符，拼接而成的一个字符串。
</code></pre><p>示例：</p>
<pre><code>[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].join(); // =&gt; &apos;a,b,c&apos;
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].join(&apos;-&apos;); // =&gt; &apos;a-b-c&apos;
</code></pre><h3 id="2-7-lastIndexOf-：在数组中反向查找匹配元素。若不存在匹配的元素时，就返回-1。查找的时候使用”-”运算符，所以要区分1和’1’"><a href="#2-7-lastIndexOf-：在数组中反向查找匹配元素。若不存在匹配的元素时，就返回-1。查找的时候使用”-”运算符，所以要区分1和’1’" class="headerlink" title="2.7 lastIndexOf ：在数组中反向查找匹配元素。若不存在匹配的元素时，就返回-1。查找的时候使用”===”运算符，所以要区分1和’1’"></a>2.7 lastIndexOf ：在数组中反向查找匹配元素。若不存在匹配的元素时，就返回-1。查找的时候使用”===”运算符，所以要区分1和’1’</h3><p>参数：</p>
<pre><code>①value ：要在数组中查找的值。

②start ：开始查找的序号位置，如果省略，则从最后一个元素开始查找。
</code></pre><p>返回值：</p>
<pre><code>{Int} ：从右到左开始查找数组中第一个匹配value的序号，若不存在，返回-1
</code></pre><p>示例：</p>
<pre><code>[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].lastIndexOf(&apos;a&apos;); // =&gt; 0
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].lastIndexOf(&apos;a&apos;, 1); // =&gt; 0
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].lastIndexOf(&apos;d&apos;); // =&gt; -1
[1, 2, 3].lastIndexOf(&apos;1&apos;); // =&gt; -1 ：采用的&apos;===&apos;匹配方式
</code></pre><h3 id="2-8-map-：依次遍历并计算每个元素，返回计算好的元素的数组"><a href="#2-8-map-：依次遍历并计算每个元素，返回计算好的元素的数组" class="headerlink" title="2.8 map() ：依次遍历并计算每个元素，返回计算好的元素的数组"></a>2.8 map() ：依次遍历并计算每个元素，返回计算好的元素的数组</h3><p>参数：</p>
<pre><code>①function(value,index,self){} ：每个元素依次调用此函数，返回计算好的元素

value ：数组遍历的元素

index ：元素序号

self ：Array本身
</code></pre><p>返回值：</p>
<pre><code>{Array} 一个包含就算好的元素的新的数组
</code></pre><p>示例：</p>
<pre><code>[1, 2, 3].map(function (value, index, self) {
return value * 2;
}); // =&gt; [2, 4, 6]
</code></pre><h3 id="2-9-pop-：移除并返回数组的最后一个元素"><a href="#2-9-pop-：移除并返回数组的最后一个元素" class="headerlink" title="2.9 pop() ：移除并返回数组的最后一个元素"></a>2.9 pop() ：移除并返回数组的最后一个元素</h3><p>参数：无</p>
<p>返回值：</p>
<pre><code>{Object} 数组的最后一个元素；若数组为空，返回undefined
</code></pre><p>示例：</p>
<pre><code>var demoArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
demoArray.pop(); // =&gt; c
demoArray.pop(); // =&gt; b
demoArray.pop(); // =&gt; a
demoArray.pop(); // =&gt; undefined
</code></pre><h3 id="2-10-push-：把元素添加到数组尾部"><a href="#2-10-push-：把元素添加到数组尾部" class="headerlink" title="2.10 push() ：把元素添加到数组尾部"></a>2.10 push() ：把元素添加到数组尾部</h3><p>参数：</p>
<pre><code>①value1,value2.....valueN ：任意多个值添加到数组尾部
</code></pre><p>返回值：</p>
<pre><code>{int} 数组新的长度 
</code></pre><p>示例：</p>
<pre><code>var demoArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
demoArray.push(&apos;d&apos;); // =&gt; 4, demoArray ： [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]
demoArray.push(&apos;e&apos;, &apos;f&apos;); // =&gt; 6, demoArray ：[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]
console.log(demoArray); // =&gt; [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;]
</code></pre><h3 id="2-11-reverse-：反转数组元素的顺序"><a href="#2-11-reverse-：反转数组元素的顺序" class="headerlink" title="2.11 reverse() ：反转数组元素的顺序"></a>2.11 reverse() ：反转数组元素的顺序</h3><p>参数：无</p>
<p>返回值：无(在原数组内进行元素顺序反转)。</p>
<p>示例：</p>
<pre><code>var demoArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
demoArray.reverse();
console.log(demoArray); // =&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
</code></pre><h3 id="2-12-shift-：移除并返回数组的第一个元素"><a href="#2-12-shift-：移除并返回数组的第一个元素" class="headerlink" title="2.12 shift() ：移除并返回数组的第一个元素"></a>2.12 shift() ：移除并返回数组的第一个元素</h3><p>参数：无</p>
<p>返回值：</p>
<pre><code>{Object} 数组的第一个元素；若数组为空，返回undefined。
</code></pre><p>示例：</p>
<pre><code>var demoArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
demoArray.shift(); // =&gt; a
demoArray.shift(); // =&gt; b
demoArray.shift(); // =&gt; c
demoArray.shift(); // =&gt; undefined
</code></pre><h3 id="2-13-slice-startIndex-endIndex-：返回数组的一部分"><a href="#2-13-slice-startIndex-endIndex-：返回数组的一部分" class="headerlink" title="2.13 slice(startIndex,endIndex) ：返回数组的一部分"></a>2.13 slice(startIndex,endIndex) ：返回数组的一部分</h3><p>参数：</p>
<pre><code>①startIndex ：开始处的序号；若为负数，表示从尾部开始计算，-1代表最后一个元素，-2倒数第二个，依此类推。

②endIndex ： 结束处的元素后一个序号，没指定就是结尾。截取的元素不包含此处序号的元素，结尾为此处序号的前一个元素。
</code></pre><p>返回值：</p>
<pre><code>{Array} 一个新的数组，包含从startIndex到endIndex前一个元素的所有元素。
</code></pre><p>示例：</p>
<pre><code>[1, 2, 3, 4, 5, 6].slice(); // =&gt; [1, 2, 3, 4, 5, 6]
[1, 2, 3, 4, 5, 6].slice(1); // =&gt; [2, 3, 4, 5, 6] ：从序号1开始截取
[1, 2, 3, 4, 5, 6].slice(0, 4); // =&gt; [1, 2, 3, 4] ：截取序号0到序号3(序号4的前一个)的元素
[1, 2, 3, 4, 5, 6].slice(-2); // =&gt; [5, 6] ：截取后面的2个元素
</code></pre><h3 id="2-14-sort-opt-orderFunc-：按一定的规则进行排序"><a href="#2-14-sort-opt-orderFunc-：按一定的规则进行排序" class="headerlink" title="2.14 sort(opt_orderFunc) ：按一定的规则进行排序"></a>2.14 sort(opt_orderFunc) ：按一定的规则进行排序</h3><p>参数：</p>
<pre><code>①opt_orderFunc(v1,v2) {Function}：可选的排序规则函数。若省略，将按照元素的字母进行从小到大排序。

v1 ：遍历时前面的元素。

v2 ：遍历时后面的元素。
</code></pre><p>排序规则：</p>
<pre><code>比较v1和v2，返回一个数字来表示v1和v2的排序规则：

小于0 ：v1小于v2，v1排在v2的前面。

等于0 ：v1等于v2，v1排在v2的前面。

大于0 ：v1大于v2，v1排在v2的后面。
</code></pre><p>返回值：无(在原先数组里进行排序操作)。</p>
<p>示例：</p>
<pre><code>[1, 3, 5, 2, 4, 11, 22].sort(); // =&gt; [1, 11, 2, 22, 3, 4, 5] ：这里都元素都被转换为字符，11的字符在2前

[1, 3, 5, 2, 4, 11, 22].sort(function (v1, v2) {
return v1 - v2;
}); // =&gt; [1, 2, 3, 4, 5, 11, 22] ：从小到大排序

[1, 3, 5, 2, 4, 11, 22].sort(function (v1, v2) {
return -(v1 - v2); //取反，就可以转换为 从大到小
}); // =&gt; [22, 11, 5, 4, 3, 2, 1]
</code></pre><h3 id="2-15-splice-：插入、删除数组元素"><a href="#2-15-splice-：插入、删除数组元素" class="headerlink" title="2.15 splice() ：插入、删除数组元素"></a>2.15 splice() ：插入、删除数组元素</h3><p>参数：</p>
<pre><code>①start {int} ：开始插入、删除或替换的起始序号。

②deleteCount {int} ：要删除元素的个数，从start处开始计算。

③value1,value2 ... valueN {Object} ：可选参数，表示要插入的元素，从start处开始插入。若②参不为0，那么先执行删除操作，再执行插入操作。
</code></pre><p>返回值：</p>
<pre><code>{Array}  返回一个包含删除元素的新的数组。若②参为0，表示没元素删除，返回一个空数组。
</code></pre><p>示例：</p>
<pre><code>// 1.删除
var demoArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
var demoArray2 = demoArray.splice(0, 2); // 删除从序号从0开始的2个元素，返回包含删除元素的数组：[&apos;a&apos;, &apos;b&apos;]
console.log(demoArray2); // =&gt; [&apos;a&apos;, &apos;b&apos;]
console.log(demoArray); // =&gt; [&apos;c&apos;, &apos;d&apos;, &apos;e&apos;]

// 2.插入
var demoArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
var demoArray2 = demoArray.splice(0, 0, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;); // ②参为0，返回空数组
console.log(demoArray2); // =&gt; [ ]
console.log(demoArray); // =&gt; [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]

// 3.先删除再插入
var demoArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
// 当②参不为0，那么先执行删除操作(删除序号从0开始的4个元素，返回包含被删除元素的数组)，再执行插入操作
var demoArray2 = demoArray.splice(0, 4, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;);
console.log(demoArray2); // =&gt; [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;] 
console.log(demoArray); // =&gt; [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;e&apos;]
</code></pre><h3 id="2-16-toString-：将数组中所有元素通过一个英文逗号’-’拼接为一个字符串"><a href="#2-16-toString-：将数组中所有元素通过一个英文逗号’-’拼接为一个字符串" class="headerlink" title="2.16 toString() ：将数组中所有元素通过一个英文逗号’,’拼接为一个字符串"></a>2.16 toString() ：将数组中所有元素通过一个英文逗号’,’拼接为一个字符串</h3><p>参数：无</p>
<p>返回值：</p>
<pre><code>{String}  数组中所有元素通过一个英文逗号&apos;,&apos;拼接为一个字符串，并返回。与调用无参join()方法一样。
</code></pre><p>示例：</p>
<pre><code>[1, 2, 3, 4, 5].toString(); // =&gt; &apos;1,2,3,4,5&apos;
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;].toString(); // =&gt; &apos;a,b,c,d,e&apos;
</code></pre><h3 id="2-17-unshift-：在数组头部插入元素"><a href="#2-17-unshift-：在数组头部插入元素" class="headerlink" title="2.17 unshift() ：在数组头部插入元素"></a>2.17 unshift() ：在数组头部插入元素</h3><p>参数：</p>
<pre><code>①value1,value2.....valueN ：任意多个值添加到数组头部
</code></pre><p>返回值：</p>
<pre><code>{int} 数组新的长度 
</code></pre><p>示例：</p>
<pre><code>var demoArray = [];
demoArray.unshift(&apos;a&apos;); // =&gt; demoArray:[&apos;a&apos;]
demoArray.unshift(&apos;b&apos;); // =&gt; demoArray:[&apos;b&apos;, &apos;a&apos;]
demoArray.unshift(&apos;c&apos;); // =&gt; demoArray:[&apos;c&apos;, &apos;b&apos;, &apos;a&apos;]
demoArray.unshift(&apos;d&apos;); // =&gt; demoArray:[&apos;d&apos;, &apos;c&apos;, &apos;b&apos;, &apos;a&apos;]
demoArray.unshift(&apos;e&apos;); // =&gt; demoArray:[&apos;e&apos;, &apos;d&apos;, &apos;c&apos;, &apos;b&apos;, &apos;a&apos;]
</code></pre><h2 id="3-静态方法"><a href="#3-静态方法" class="headerlink" title="3. 静态方法"></a>3. 静态方法</h2><h3 id="3-1-Array-isArray-：判断对象是否为数组"><a href="#3-1-Array-isArray-：判断对象是否为数组" class="headerlink" title="3.1 Array.isArray() ：判断对象是否为数组"></a>3.1 Array.isArray() ：判断对象是否为数组</h3><p>参数：</p>
<pre><code>①value {Object}：任意对象
</code></pre><p>返回值：</p>
<pre><code>{Boolean}  返回判断结果。当为 true时，表示对象为数组；为false时，表示对象不是数组
</code></pre><p>示例：</p>
<pre><code>Array.isArray([]); // =&gt; true
Array.isArray([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]); // =&gt; true
Array.isArray(&apos;a&apos;); // =&gt; false
Array.isArray(&apos;[1, 2, 3]&apos;); // =&gt; false
</code></pre><h2 id="4-实际操作"><a href="#4-实际操作" class="headerlink" title="4. 实际操作"></a>4. 实际操作</h2><h3 id="4-1-索引"><a href="#4-1-索引" class="headerlink" title="4.1 索引"></a>4.1 索引</h3><p>说明：</p>
<pre><code>每个元素在数组中有一个位置，以数字表示，称为索引。索引是从0开始计，即第一个元素的索引为0，第二个元素的索引为1，依此类推；

    当获取一个数组不存在的索引时，返回 undefined。
</code></pre><p>示例：</p>
<pre><code>var demoArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
demoArray[0]; // =&gt; 获取第一个元素:&apos;a&apos;
demoArray[0] = 1;  // 设置第一个元素为 1
console.log(demoArray); // =&gt; demoArray:[1, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]
console.log(demoArray[9]); // =&gt; undefined ：当获取的索引不存在时，返回 undefined
</code></pre><h3 id="4-2-for-语句"><a href="#4-2-for-语句" class="headerlink" title="4.2 for 语句"></a>4.2 for 语句</h3><p>说明：</p>
<pre><code>可以通过for语句逐个遍历数组
</code></pre><p>示例：</p>
<pre><code>var demoArray = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
for (var i = 0, length = demoArray.length; i &lt; length; i++) {
console.log(demoArray[i]); // =&gt; 逐个输出数组内的元素
}
</code></pre><h3 id="4-3-浅度复制"><a href="#4-3-浅度复制" class="headerlink" title="4.3 浅度复制"></a>4.3 浅度复制</h3><p>说明：</p>
<pre><code>Array类型是一种引用类型；当数组a复制给数组b时，对数组b进行元素修改，数组a也会发生修改。
</code></pre><p>示例：</p>
<pre><code>var demoArrayA = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
var demoArrayB = demoArrayA; // 把数组A 赋值给数组B
demoArrayB[0] = 1; // 对数组B 的元素进行修改
console.log(demoArrayA); // =&gt; [1, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]：数组A 的元素也发生了变更
</code></pre><h3 id="4-4-深度复制"><a href="#4-4-深度复制" class="headerlink" title="4.4 深度复制"></a>4.4 深度复制</h3><p>说明：</p>
<pre><code>使用concat()方法，返回新的数组；防止浅度复制的情况发生，对数组b进行元素修改操作，数组a不发生变更。
</code></pre><p>示例：</p>
<pre><code>var demoArrayA = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
var demoArrayB = demoArrayA.concat(); // 使用concat()方法，返回新的数组
demoArrayB[0] = 1; // 对数组B 的元素进行修改
console.log(demoArrayA); // =&gt; [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]：数组A 的元素没变更
console.log(demoArrayB); // =&gt; [  1, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]：数组B 的元素发生了变更
</code></pre><h3 id="4-5-判断2个数组是否相等"><a href="#4-5-判断2个数组是否相等" class="headerlink" title="4.5 判断2个数组是否相等"></a>4.5 判断2个数组是否相等</h3><p>说明：</p>
<pre><code>Array数组为引用类型，所以哪怕 []===[] 都会返回false，所以可通过数组toString()方法返回的字符串判断是否相等。
</code></pre><p>示例：</p>
<pre><code>console.log([]===[]); // =&gt; false
console.log([&apos;a&apos;, &apos;b&apos;] === [&apos;a&apos;, &apos;b&apos;]); // =&gt; false
console.log([&apos;a&apos;, &apos;b&apos;].toString() === [&apos;a&apos;, &apos;b&apos;].toString()); // true
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016 yuxuan
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>